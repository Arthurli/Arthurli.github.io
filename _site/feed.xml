<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 03 Feb 2015 22:12:57 +0800</pubDate>
    <lastBuildDate>Tue, 03 Feb 2015 22:12:57 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Objective-C-RegEx-Categories 正则表达式</title>
        <description>&lt;h1 id=&quot;nsregularexpression&quot;&gt;NSRegularExpression&lt;/h1&gt;
&lt;p&gt;这是一个使用正则表达式解析字符串的类，下面是他的一些options&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct NSRegularExpressionOptions : RawOptionSetType {
    init(_ rawValue: UInt)
    init(rawValue: UInt)
    
    static var CaseInsensitive: NSRegularExpressionOptions { get } 
    /* Match letters in the pattern independent of case. */
    static var AllowCommentsAndWhitespace: NSRegularExpressionOptions { get } 
    /* Ignore whitespace and #-prefixed comments in the pattern. */
    static var IgnoreMetacharacters: NSRegularExpressionOptions { get } 
    /* Treat the entire pattern as a literal string. */
    static var DotMatchesLineSeparators: NSRegularExpressionOptions { get }
     /* Allow . to match any character, including line separators. */
    static var AnchorsMatchLines: NSRegularExpressionOptions { get } 
    /* Allow ^ and $ to match the start and end of lines. */
    static var UseUnixLineSeparators: NSRegularExpressionOptions { get } 
    /* Treat only \n as a line separator (otherwise, all standard line separators are used). */
    static var UseUnicodeWordBoundaries: NSRegularExpressionOptions { get }
     /* Use Unicode TR#29 to specify word boundaries (otherwise, traditional regular expression word boundaries are used). */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是每次扫描的options&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct NSMatchingOptions : RawOptionSetType {
    init(_ rawValue: UInt)
    init(rawValue: UInt)
    
    static var ReportProgress: NSMatchingOptions { get } 
    /* Call the block periodically during long-running match operations. */
    static var ReportCompletion: NSMatchingOptions { get } 
    /* Call the block once after the completion of any matching. */
    static var Anchored: NSMatchingOptions { get }
     /* Limit matches to those at the start of the search range. */
    static var WithTransparentBounds: NSMatchingOptions { get } 
    /* Allow matching to look beyond the bounds of the search range. */
    static var WithoutAnchoringBounds: NSMatchingOptions { get }
     /* Prevent ^ and $ from automatically matching the beginning and end of the search range. */
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;nstextcheckingresult&quot;&gt;NSTextCheckingResult&lt;/h3&gt;
&lt;p&gt;这是一个搜索返回的结果类&lt;/p&gt;

&lt;h1 id=&quot;objective-c-regex-categories&quot;&gt;Objective-C-RegEx-Categories&lt;/h1&gt;
&lt;p&gt;这个库就是NSRegularExpression的拓展类别&lt;br /&gt;
它定义了两个用来设置搜索参数和返回搜索结果，主要是对NSTextCheckingResult的封装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface RxMatch : NSObject
@property (nonatomic, copy)     NSString* value;    /* The substring that matched the expression. */
@property (nonatomic, assign)   NSRange   range;    /* The range of the original string that was matched. */
@property (nonatomic, copy)     NSArray*  groups;   /* Each object is an RxMatchGroup. */
@property (nonatomic, copy)     NSString* original; /* The full original string that was matched against.  */
@end


@interface RxMatchGroup : NSObject
@property (nonatomic, copy)   NSString* value;
@property (nonatomic, assign) NSRange range;
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当让，这个库里面还有一个NSString的类别，几乎是与NSRegularExpression类别一一对应的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//直接匹配字符
- (BOOL) isMatch:(NSString*)matchee
//直接返回匹配位置
- (int) indexOf:(NSString*)matchee
//简单替换
- (NSString*) replace:(NSString*)string with:(NSString*)replacement
//返回第一个匹配字符串
- (NSString*) firstMatch:(NSString*)str
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section&quot;&gt;正则表达式&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://deerchao.net/tutorials/regex/regex.htm&quot;&gt;半小时正则&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 03 Feb 2015 00:00:00 +0800</pubDate>
        <link>/2015/02/03/regular.html</link>
        <guid isPermaLink="true">/2015/02/03/regular.html</guid>
        
        
      </item>
    
      <item>
        <title>OCMockito学习</title>
        <description>&lt;h1 id=&quot;mock&quot;&gt;Mock是什么&lt;/h1&gt;
&lt;p&gt;mock测试就是在测试过程中，对于某些不容易构造或者 不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。&lt;br /&gt;
下面是百度百科对于Mock关键词的一些描述&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mock对象
这个虚拟的对象就是mock对象。mock对象就是真实对象在调试期间的代替品。

mock对象使用范畴
真实对象具有不可确定的行为，产生不可预测的效果，（如：股票行情，天气预报） 真实对象很难被创建的 真实对象的某些行为很难被触发 真实对象实际上还不存在的（和其他开发小组或者和新的硬件打交道）等等.

使用mock对象测试的关键步骤
使用一个接口来描述这个对象 在产品代码中实现这个接口 在测试代码中实现这个接口 在被测试代码中只是通过接口来引用对象，所以它不知道这个引用的对象是真实对象还是mock对象。

MockObject
使用Mock Object进行测试，主要是用来模拟那些在应用中不容易构造（如HttpServletRequest必须在Servlet容器中才能构造出来）或者比较复杂的对象（如JDBC中的ResultSet对象）从而使测试顺利进行的工具。
目前，在Java阵营中主要的Mock测试工具有JMock，MockCreator，Mockrunner，EasyMock，MockMaker等，在微软的.Net阵营中主要是Nmock，.NetMock等。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;mockito&quot;&gt;Mockito&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://mockito.org/&quot;&gt;Mockito&lt;/a&gt;官网&lt;/p&gt;

&lt;p&gt;我们做测试的时候最纠结的就是可能测试数据涉及到了很多类，我们又不能有对他们一一依赖，所以我们采用一种Mock的模型对象来作为测试使用的某些替代品。 
verify是Mockito的一种十分重要的方法，能检验是否Mock对象的某些方法被调用过,但是没有前后顺序的排列&lt;br /&gt;
verify还可以加一些限制条件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// mock creation
NSMutableArray *mockArray = mock([NSMutableArray class]);

// using mock object
[mockArray addObject:@&quot;one&quot;];
[mockArray removeAllObjects];

// verification
[verify(mockArray) addObject:@&quot;one&quot;];
[verify(mockArray) removeAllObjects];

//加上限制条件
[verifyCount(mockObject, times(5)) someMethod:@&quot;was called five times&quot;];
[verifyCount(mockObject, never()) someMethod:@&quot;was never called&quot;];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种方法，让我们可以设置相关对mock对象引用的返回值
在iOSZ中是下面这样实现的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// mock creation
NSArray *mockArray = mock([NSArray class]);

// stubbing
[given([mockArray objectAtIndex:0]) willReturn:@&quot;first&quot;];
[given([mockArray objectAtIndex:1]) willThrow:[NSException exceptionWithName:@&quot;name&quot;
                                                                      reason:@&quot;reason&quot;
                                                                    userInfo:nil]];

// following prints &quot;first&quot;
NSLog(@&quot;%@&quot;, [mockArray objectAtIndex:0]);

// follows throws exception
NSLog(@&quot;%@&quot;, [mockArray objectAtIndex:1]);

// following prints &quot;(null)&quot; because objectAtIndex:999 was not stubbed
NSLog(@&quot;%@&quot;, [mockArray objectAtIndex:999]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Argument Matcher（参数匹配器）,针对参数对象，也可以进行某些模拟（在iOS中，使用OCHamcrest实现）例如下面的 startsWith(@”This is”)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// mock creation
NSMutableArray *mockArray = mock([NSMutableArray class]);

// using mock object
[mockArray removeObject:@&quot;This is a test&quot;];

// verification
[verify(mockArray) removeObject:startsWith(@&quot;This is&quot;)];
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;ocmockito&quot;&gt;OCMockito&lt;/h1&gt;

&lt;p&gt;安装，我是用的是COCOAPOD安装，安装的时候遇到很大的问题困扰我，就是targrt我刚开始写成了非测试的项目，然后就是各种运行不了，所以大家要万分注意&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Podfile
target :MyTests, :exclusive =&amp;gt; true do
  pod &#39;OCMockito&#39;, &#39;~&amp;gt; 1.0&#39;
end
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 03 Feb 2015 00:00:00 +0800</pubDate>
        <link>/2015/02/03/Mock.html</link>
        <guid isPermaLink="true">/2015/02/03/Mock.html</guid>
        
        
      </item>
    
      <item>
        <title>MJExtension 解析</title>
        <description>&lt;h1 id=&quot;mjextension-&quot;&gt;MJExtension 介绍&lt;/h1&gt;
&lt;p&gt;这是一个把字典转换成为对象的库，按照作者的意思，它的效率是其他解决方案的数倍，那么，今天让我们来学习一下他是怎么来实现的&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;类的解析&lt;/h2&gt;

&lt;h3 id=&quot;mjfoundation&quot;&gt;MJFoundation&lt;/h3&gt;
&lt;p&gt;这个类来判断传入类型是否可以被解析，也就是说是否来自 NSFoundation&lt;/p&gt;

&lt;h3 id=&quot;mjtype&quot;&gt;MJType&lt;/h3&gt;
&lt;p&gt;是一种类型封装,每种Type都是唯一的存在，保存在字典中&lt;/p&gt;

&lt;h3 id=&quot;mjivar&quot;&gt;MJIvar&lt;/h3&gt;
&lt;p&gt;是一个属性的封装,利用Ivar进行初始化，然后通过下面的方法存取和调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MJIvar *ivarObject = objc_getAssociatedObject(self, ivar);
    if (ivarObject == nil) {
        ivarObject = [[self alloc] initWithIvar:ivar];
        objc_setAssociatedObject(self, ivar, ivarObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个类的功能就是通过Ivar获取一些信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString *name = @(ivar_getName(ivar));
NSString *code = @(ivar_getTypeEncoding(ivar));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过初试化之后，MJIvar就拥有了自己的属性名，这样就可以给把它作为KEY，再把传进来的字典进行设置或者提取属性  &lt;/p&gt;

&lt;h3 id=&quot;nsobjectmjivar&quot;&gt;NSObject+MJIvar&lt;/h3&gt;
&lt;p&gt;这里面的方法是遍历当前类的属性，或者直接遍历父类的属性，然后通过block回调&lt;/p&gt;

&lt;h3 id=&quot;nsobjectmjcoding&quot;&gt;NSObject+MJCoding&lt;/h3&gt;
&lt;p&gt;这里面实现了遍历的编码和解码，使用NSObject+MJIvar中的方法会把所有属性都回调回来，我们就可以通过MJLvar来直接编码或者解码&lt;/p&gt;

&lt;h3 id=&quot;nsobjectmjkeyvalue&quot;&gt;NSObject+MJKeyValue&lt;/h3&gt;
&lt;p&gt;首先这个类中定义了一些列协议，用作字典与对象的key不相同时候的转化，还有完成转换之后调用的代理&lt;br /&gt;
然后就是一些转化方法，具体的转化方法就是先讲一切转化成字典，然后遍历类中的所有属性，然后再依次从字典中取出值，然后赋值&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这个类库究竟帮我们做了什么呢，其实就是把我们平时需要手动的一个一个取得值，赋的值，通过运行时获取到这个类中的所有属性，然后帮我们依次去赋值&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jan 2015 00:00:00 +0800</pubDate>
        <link>/2015/01/29/MJExtension.html</link>
        <guid isPermaLink="true">/2015/01/29/MJExtension.html</guid>
        
        
      </item>
    
      <item>
        <title>iOS开发进阶 读书笔记</title>
        <description>&lt;h1 id=&quot;ios-&quot;&gt;iOS开发进阶 读书笔记&lt;/h1&gt;

&lt;p&gt;失望 失望 失望 没别的了&lt;/p&gt;

&lt;h2 id=&quot;ios&quot;&gt;第二部分iOS开发实践&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;第十章 内存管理&lt;/h3&gt;
&lt;p&gt;关闭ARC &lt;code&gt;-fno-objc-arc&lt;/code&gt;,iOS的引用计数与Linux的硬链接相似&lt;br /&gt;
使用弱引用解决循环引用的问题  &lt;/p&gt;

&lt;h3 id=&quot;gcd&quot;&gt;第十一章 GCD&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;BLOCK定义

(void)(^ loggerBlock)(void);
loggerBlock = ^{
  NSLog(@&quot;123&quot;);
}
loggerBlock();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;block使用外部的属性 需要加上 __block 的标示
###第十二章 UIWindow
常被用作广告页，介绍页，解锁页等等
###第十五章 UIWebView
web模板 两个开源库 MGTemplateEngine GRMustache&lt;br /&gt;
cordova 方案传递参数&lt;br /&gt;
###第十八章 实战
持久化 NSJSONSerialization比NSKeyedArchiver好&lt;/p&gt;

</description>
        <pubDate>Fri, 23 Jan 2015 00:00:00 +0800</pubDate>
        <link>/2015/01/23/iOS-tq.html</link>
        <guid isPermaLink="true">/2015/01/23/iOS-tq.html</guid>
        
        
      </item>
    
      <item>
        <title>各种缓存机制和实现方式</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;各种缓存机制和实现方式&lt;/h1&gt;
&lt;p&gt;今天我们要看的就是缓存机制，在我们的计算机世界里面，内存和速度是怎么都会觉得不够的，当然这只是我自己的感觉而已。那么今天我们就来看看一般的缓存都是如何做的吧&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;为什么使用缓存呢&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;我感觉第一点就是加快访问速度，不适用内存级别的缓存的话，就只能使用数据库，那么频繁的数据库IO自然会使得速度变慢，从而造成用户的流失。  &lt;/li&gt;
  &lt;li&gt;大量的数据库访问自然会增大出现问题的几率，增大请求次数，从而增加不必要的成本&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;那么我们来聊聊缓存吧&lt;/h2&gt;

&lt;p&gt;缓存说白了就是一堆内存中或者数据库中的数据，需要被用户使用，所以放到一个叫做缓存池的地方，大家通过一个唯一标示ID来表明身份，如果缓存数大于上线，那么会根据缓存算法清除掉一些缓存&lt;br /&gt;
还有关于缓存拥有一大堆高大上的术语，想知道的点&lt;a href=&quot;http://unicorn.blog.51cto.com/2273096/444605&quot;&gt;这里&lt;/a&gt;  &lt;/p&gt;

&lt;h2 id=&quot;lfu&quot;&gt;LFU缓存算法&lt;/h2&gt;
&lt;p&gt;LFU 的英文就是 least frequently used, 核心思想就是按照使用频域来排序， 记录缓存的使用频率，然后使用它排序，之后每进来一个新的 就替换掉使用频率最低的换粗  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/LFU.png&quot; alt=&quot;&quot; /&gt;  &lt;/p&gt;

&lt;p&gt;实现起来是这样的(这是我自己想的一种算法实现，不一定是最优解)，缓存池维护一个字典和一个数组，字典存储Key和一个下标数字或者对象（是用于定位用的），而数组则是用来排序的，每次有新的缓存的话，重新排序，然后把最新的数据删除&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/yunhua_lee/article/details/7648549&quot;&gt;这里是别处的详细说明&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/Arthurli/LFUCacheKit&quot;&gt;这里有我用Swift写的一个小实现&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;几种变体&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LFU* : 只删除引用计数为一的缓存数据，如果没有为一的，那么不存储缓存&lt;/li&gt;
  &lt;li&gt;LFU-Aging : 在引用计数的维度上增加一个增加时间，但是这个时间并不是真正的时间，而是根据一个平均引用计数，当平均引用计数达到一定值的时候，所有引用计数减少，可以直接减半，或者减去一个固定的值，然后从新排序&lt;/li&gt;
  &lt;li&gt;LFU*-Aging : 结合以上两种算法&lt;/li&gt;
  &lt;li&gt;Window-LFU : LRU的改进版，只维护一定时间内的引用计数，我的实现方法就是增加一个栈维护请求，此请求数组达到上限，推出最早的请求，引用计数减一，然后从新排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lru&quot;&gt;LRU&lt;/h2&gt;
&lt;p&gt;LRU的英文是Least Recently Used,简单来说就是把最久不使用的缓存删除，每次有新的缓存都会把他放到栈顶，然后从栈的底部推出最久不使用的缓存&lt;br /&gt;
简单的原理图就像下面画的&lt;br /&gt;
&lt;img src=&quot;/assets/img/LRU.png&quot; alt=&quot;&quot; /&gt;  &lt;br /&gt;
还是不太清楚？那么我们来看这个&lt;br /&gt;
&lt;img src=&quot;/assets/img/LRU-1.png&quot; alt=&quot;&quot; /&gt; &lt;br /&gt;
永远都是把最近访问的缓存放到顶部，然后把底部的缓存删除&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/yunhua_lee/article/details/7599671&quot;&gt;这里是别处的详细说明&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/Arthurli/LRUCacheKit&quot;&gt;这里有我用Swift写的一个小实现&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;几种变体&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LRU2 : 按我的理解就是维护一个LFU队列和一个LRU队列，当LFU队列的访问数达到某个值，则从LFU队列中移动到LRU队列，两个队列如果超出，都是用各自的方式删除缓存&lt;/li&gt;
  &lt;li&gt;2Q : 和LRU2相类似，不过换成了维护一个FIFO队列和LRU队列&lt;/li&gt;
  &lt;li&gt;MRU (Most Recently Used): 最近最常使用缓存算法，与LRU完全相反，首先删除最新的缓存，多应用于文件顺序执行的场景&lt;/li&gt;
  &lt;li&gt;MQ : 维护多个拥有优先级设定的LRU队列，然后根据访问次数，和被访问时间升降优先级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/LRU-MQ.png&quot; alt=&quot;&quot; /&gt;   &lt;/p&gt;

&lt;h2 id=&quot;fifo&quot;&gt;FIFO&lt;/h2&gt;
&lt;p&gt;原始版的FIFO就是先进先出，除了快也就没什么优点了，咱们主要说说几种变化&lt;br /&gt;
###Second Chance 
核心思想就是数据被淘汰前被访问过两次则再给他个机会，什么叫给机会呢，如果访问数大于2，则把重置访问数，然后把这个缓存从队头移动到队尾
###Clock
Clock是Second Chance的改进版，通过一个环形队列，避免将数据在FIFO队列中移动。&lt;br /&gt;
它只需要移动指针就好了，优于Second Chance&lt;/p&gt;

&lt;h2 id=&quot;adaptive-replacement-cachearc&quot;&gt;Adaptive Replacement Cache（ARC）&lt;/h2&gt;
&lt;p&gt;学过oc的都激动了，我懂，我说，你懂个毛线，不一样好吗，说的不是一个东西好吗&lt;br /&gt;
那么什么叫做ARC呢，其实也就是维护了两个LRU队列，然后…然后…&lt;/p&gt;

&lt;p&gt;我就简单说说，说的不好。维护两个LRU队列，每个队列还有一个垃圾箱，我们分别取名T1,L1,T2,L2  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新数据进入L1&lt;/li&gt;
  &lt;li&gt;多次被访问进入L2&lt;/li&gt;
  &lt;li&gt;L1被移除进入T1，L2被移除进入T2&lt;/li&gt;
  &lt;li&gt;T2满了，进入L1，T1满了被真正移出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Adaptive_replacement_cache#Deployment&quot;&gt;这里是详细&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;其实缓存算法还有很多很多，我们现在说的只是最常使用的几个缓存算法，我们需要根据不同的使用场景选择适合我们的算法&lt;/p&gt;

</description>
        <pubDate>Wed, 14 Jan 2015 00:00:00 +0800</pubDate>
        <link>/2015/01/14/cache.html</link>
        <guid isPermaLink="true">/2015/01/14/cache.html</guid>
        
        
      </item>
    
      <item>
        <title>SQL细节补全</title>
        <description>&lt;h1 id=&quot;sql&quot;&gt;SQL细节补全&lt;/h1&gt;
&lt;p&gt;-
The SELECT DISTINCT statement is used to return only distinct (different) values.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT DISTINCT column_name,column_name
FROM table_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ORDER BY keyword is used to sort the result-set.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT column_name,column_name
FROM table_name
ORDER BY column_name,column_name ASC|DESC;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The INSERT INTO statement is used to insert new records in a table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO table_name (column1,column2,column3,...)
VALUES (value1,value2,value3,...);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The UPDATE statement is used to update records in a table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UPDATE table_name
SET column1=value1,column2=value2,...
WHERE some_column=some_value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The SELECT TOP clause is used to specify the number of records to return.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name
LIMIT number;

SELECT TOP number|percent column_name(s)
FROM table_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQL Wildcard Characters&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Wildcard&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;%&lt;/td&gt;
      &lt;td&gt;A substitute for zero or more characters&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;_&lt;/td&gt;
      &lt;td&gt;A substitute for a single character&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[charlist]&lt;/td&gt;
      &lt;td&gt;Sets and ranges of characters to match&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[^charlist] or [!charlist]&lt;/td&gt;
      &lt;td&gt;Matches only a character NOT specified within the brackets&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;SQL aliases are used to temporarily rename a table or a column heading.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT column_name AS alias_name
FROM table_name;

SELECT column_name(s)
FROM table_name AS alias_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The SQL UNION operator combines the result of two or more SELECT statements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;

//Note: The UNION operator selects only distinct values by default. To allow duplicate values, use the ALL keyword with UNION.

SELECT column_name(s) FROM table1
UNION ALL
SELECT column_name(s) FROM table2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With SQL, you can copy information from one table into another.&lt;/p&gt;

&lt;p&gt;The SELECT INTO statement copies data from one table and inserts it into a new table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT *
INTO newtable [IN externaldb]
FROM table1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With SQL, you can copy information from one table into another.&lt;/p&gt;

&lt;p&gt;The INSERT INTO SELECT statement copies data from one table and inserts it into an existing table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO table2
(column_name(s))
SELECT column_name(s)
FROM table1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create Table&lt;/p&gt;

&lt;p&gt;In SQL, we have the following constraints:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NOT NULL - Indicates that a column cannot store NULL value&lt;/li&gt;
  &lt;li&gt;UNIQUE - Ensures that each row for a column must have a unique value&lt;/li&gt;
  &lt;li&gt;PRIMARY KEY - A combination of a NOT NULL and UNIQUE. Ensures that a column (or combination of two or more columns) have an unique identity which helps to find a particular record in a table more easily and quickly&lt;/li&gt;
  &lt;li&gt;FOREIGN KEY - Ensure the referential integrity of the data in one table to match values in another table&lt;/li&gt;
  &lt;li&gt;CHECK - Ensures that the value in a column meets a specific condition&lt;/li&gt;
  &lt;li&gt;DEFAULT - Specifies a default value when specified none for this column&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE Persons
(
PersonID int,
LastName varchar(255),
FirstName varchar(255),
Address varchar(255),
City varchar(255)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The CREATE INDEX statement is used to create indexes in tables.&lt;/p&gt;

&lt;p&gt;Indexes allow the database application to find data fast; without reading the whole table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE INDEX index_name
ON table_name (column_name)

CREATE UNIQUE INDEX index_name
ON table_name (column_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ALTER TABLE statement is used to add, delete, or modify columns in an existing table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name
ADD column_name datatype

ALTER TABLE table_name
DROP COLUMN column_name

//SQL Server / MS Access:

ALTER TABLE table_name
ALTER COLUMN column_name datatype

//My SQL / Oracle:

ALTER TABLE table_name
MODIFY COLUMN column_name datatype

//Oracle 10G and later:

ALTER TABLE table_name
MODIFY column_name datatype

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Auto-increment allows a unique number to be generated when a new record is inserted into a table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE Persons
(
ID int NOT NULL AUTO_INCREMENT,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (ID)
)

ALTER TABLE Persons AUTO_INCREMENT=100
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 12 Jan 2015 00:00:00 +0800</pubDate>
        <link>/2015/01/12/sql.html</link>
        <guid isPermaLink="true">/2015/01/12/sql.html</guid>
        
        
      </item>
    
      <item>
        <title>JQuery 学习笔记</title>
        <description>&lt;h1 id=&quot;jquery-&quot;&gt;JQuery 学习笔记&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;选择器&lt;/h2&gt;
&lt;p&gt;使用$()选择JQuery对象，他的选择器与CSS的选择器十分的类似&lt;br /&gt;
当然JQuery拥有一些自定义的选择符号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:eq(1)      //第几个元素
:odd    	//偶数的元素
:even       //基数的元素
:nth-child()    //这个选择符相对于元素的父元素而非当前选择的所有元素来计算位置，它可以接受数值、odd或even作为参数
:contains()     //这个区分大小
之后还有一系列基于表单的选择符

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在选择后，其实选择的是一个数组，那么其实可以通过下面的方法获取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myTag = $(&#39;#myTag&#39;)[0].tagName
var myTags = $(&#39;#myTag&#39;).get(0).tagName
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;事件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$(document).ready()    //页面加载后调用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绑定事件使用bind()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function() {
  $(&#39;#switcher-large&#39;).bind(&#39;click&#39;, function() {
    $(&#39;body&#39;).addClass(&#39;large&#39;);
  });
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用$(this)在function中 代表这个对象&lt;br /&gt;
下面是一些事件&lt;br /&gt;
&lt;img src=&quot;/assets/img/jquery1.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
下面再说一些事件流程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 事件目标
// 未完成的代码
$(document).ready(function() {
  $(&#39;#switcher&#39;).click(function(event) {
    if (event.target == this) {
      $(&#39;#switcher button&#39;).toggleClass(&#39;hidden&#39;);
    }
  });
}); 

// 停止事件传播
$(document).ready(function() {
  $(&#39;#switcher&#39;).click(function(event) {
    $(&#39;#switcher button&#39;).toggleClass(&#39;hidden&#39;);
  });
});

$(document).ready(function() {
  $(&#39;#switcher-default&#39;).addClass(&#39;selected&#39;);

  $(&#39;#switcher button&#39;).click(function(event) {
    var bodyClass = this.id.split(&#39;-&#39;)[1];

    $(&#39;body&#39;).removeClass().addClass(bodyClass);

    $(&#39;#switcher button&#39;).removeClass(&#39;selected&#39;);
    $(this).addClass(&#39;selected&#39;);
    event.stopPropagation();
  });
}); 

// 判断this属性
$(document).ready(function() {
  $(&#39;#switcher&#39;).click(function(event) {
    if ($(event.target).is(&#39;button&#39;)) {  //使用 is 判断
      var bodyClass = event.target.id.split(&#39;-&#39;)[1];

      $(&#39;body&#39;).removeClass().addClass(bodyClass);

      $(&#39;#switcher button&#39;).removeClass(&#39;selected&#39;);
      $(event.target).addClass(&#39;selected&#39;);
      event.stopPropagation();
    }
  });
}); 

// 事件委托 ，有很多种方法 比如live,die等等
$(&#39;#switcher button&#39;).live(&#39;click&#39;, function() {
  var bodyClass = event.target.id.split(&#39;-&#39;)[1];

  $(&#39;body&#39;).removeClass().addClass(bodyClass);

  $(&#39;#switcher button&#39;).removeClass(&#39;selected&#39;);
  $(this).addClass(&#39;selected&#39;);
}); 

// 模仿用户
$(document).ready(function() {
  $(&#39;#switcher&#39;).trigger(&#39;click&#39;);
}); 

//从键盘输入
$(document).ready(function() {
  var triggers = {
    D: &#39;default&#39;,
    N: &#39;narrow&#39;,
    L: &#39;large&#39;
  };

  $(document).keyup(function(event) {
    var key = String.fromCharCode(event.keyCode);
    if (key in triggers) {
      $(&#39;#switcher-&#39; + triggers[key]).click();
    }
  });
}); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;样式与动画&lt;/h2&gt;
&lt;p&gt;首先 .css() 这个方法 继承了getter和setter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 单个属性及其值
.css(&#39;property&#39;, &#39;value&#39;)
// 属性-值对构成
.css({
  property1: &#39;value1&#39;,
  &#39;property-2&#39;: &#39;value2&#39;
}) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用hide和show现实和隐藏元素，其中还可以使用’slow’、’normal’和’fast’来当做速度的参数&lt;br /&gt;
我们使用fadeIn和fadeOut实现淡出和淡入 &lt;br /&gt;
使用和slideDown和slideUp实现划上和滑下&lt;br /&gt;
jquery还可以使用。animate()自定义动画，这里面有可以设置该标的元素，速度，回调等，是一个并发的方法，&lt;br /&gt;
如果我们需要一个队列效果执行的动画呢，可以连缀多个animate()动画&lt;br /&gt;
如果在速度选项中添加 queue:false，则不是使用队列触发&lt;/p&gt;

&lt;h2 id=&quot;dom&quot;&gt;DOM操作&lt;/h2&gt;
&lt;p&gt;我们可以使用addClass()和removeClass()来添加Class，对于其他的一些属性，我们则可以通过attr()和removeAttr()来添加和删除。&lt;br /&gt;
使用attr赋值的时候其实可以不传值，传递一个function这样每次都会调用这个方法&lt;br /&gt;
在jQuery可以使用.prop获取属性   &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 取得 &quot;checked&quot; 属性的当前值
var currentlyChecked = $(&#39;.my-checkbox&#39;).prop(&#39;checked&#39;);

// 设置 &quot;checked&quot; 属性的值
$(&#39;.my-checkbox&#39;).prop(&#39;checked&#39;, false); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###添加，移动元素
(1) .insertBefore()在现有元素外部、之前添加内容；&lt;br /&gt;
(2) .prependTo()在现有元素内部、之前添加内容；&lt;br /&gt;
(3) .appendTo()在现有元素内部、之后添加内容；&lt;br /&gt;
(4) .insertAfter()在现有元素外部、之后添加内容。&lt;br /&gt;
与之对应的还有反向插入方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function() {
  $(&#39;&amp;lt;a href=&quot;#top&quot;&amp;gt;back to top&amp;lt;/a&amp;gt;&#39;).insertAfter(&#39;div.chapterp&#39;);
  $(&#39;&amp;lt;a id=&quot;top&quot;&amp;gt;&amp;lt;/a&amp;gt;&#39;).prependTo(&#39;body&#39;);
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;移动元素和插入元素相似，只不过是选择已经存在的元素  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//包装元素
$(document).ready(function() {
  $(&#39;span.footnote&#39;)
    .insertBefore(&#39;#footer&#39;)
    .wrapAll(&#39;&amp;lt;ol id=&quot;notes&quot;&amp;gt;&amp;lt;/ol&amp;gt;&#39;) //我们使用.wrapAll()把所有脚注都包含在一个&amp;lt;ol&amp;gt;中
    .wrap(&#39;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&#39;); //使用.wrap()将每一个脚注分别包装在自己的&amp;lt;li&amp;gt;中
});

//复制
$(&#39;123&#39;).clone()
$(&#39;123&#39;).clone(true) //同时复制事件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###简单总结
对于jQuery提供的大量DOM操作方法，应该根据要完成的任务和元素的位置作出不同的选择。本章只介绍了一部分DOM操作方法，但其他方法的使用与这些方法类似；第12章还将更全面地讨论DOM操作方法。下面，我们简单地归纳出一些方法，这些方法几乎能够在任何情况下，完成任何任务。&lt;br /&gt;
(1) 要在HTML中创建新元素，使用$()函数。&lt;br /&gt;
(2) 要在每个匹配的元素中插入新元素，使用：&lt;br /&gt;
append()&lt;br /&gt;
appendTo()&lt;br /&gt;
prepend()
prependTo()&lt;br /&gt;
(3) 要在每个匹配的元素相邻的位置上插入新元素，使用：&lt;br /&gt;
after()&lt;br /&gt;
insertAfter()&lt;br /&gt;
before()&lt;br /&gt;
insertBefore()&lt;br /&gt;
(4) 要在每个匹配的元素外部插入新元素，使用： 
wrap()&lt;br /&gt;
wrapAll()&lt;br /&gt;
wrapInner()&lt;br /&gt;
(5) 要用新元素或文本替换每个匹配的元素，使用：&lt;br /&gt;
html()&lt;br /&gt;
text()&lt;br /&gt;
replaceAll()&lt;br /&gt;
replaceWith()&lt;br /&gt;
(6) 要移除每个匹配的元素中的元素，使用：&lt;br /&gt;
empty()&lt;br /&gt;
(7) 要从文档中移除每个匹配的元素及其后代元素，但不实际删除它们，使用：&lt;br /&gt;
remove()&lt;br /&gt;
detach()  &lt;/p&gt;

&lt;h2 id=&quot;ajax&quot;&gt;AJAX的使用&lt;/h2&gt;
&lt;p&gt;在下面的事件中返回false,防止跳转&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//简单加载html
$(document).ready(function() {
  $(&#39;#letter-a a&#39;).click(function() {
    $(&#39;#dictionary&#39;).load(&#39;a.html&#39;);
    return false;
  });
}); 

//加载JSON
$(document).ready(function() {
  $(&#39;#letter-b a&#39;).click(function() {
    $.getJSON(&#39;b.json&#39;, function(data) {
      var html = &#39;&#39;;
      $.each(data, function(entryIndex, entry) {
        html += &#39;&amp;lt;div class=&quot;entry&quot;&amp;gt;&#39;;
        html += &#39;&amp;lt;h3 class=&quot;term&quot;&amp;gt;&#39; + entry.term + &#39;&amp;lt;/h3&amp;gt;&#39;;
        html += &#39;&amp;lt;div class=&quot;part&quot;&amp;gt;&#39; + entry.part + &#39;&amp;lt;/div&amp;gt;&#39;;
        html += &#39;&amp;lt;div class=&quot;definition&quot;&amp;gt;&#39;;
        html += entry.definition;
        html += &#39;&amp;lt;/div&amp;gt;&#39;;
        html += &#39;&amp;lt;/div&amp;gt;&#39;;
      });
      $(&#39;#dictionary&#39;).html(html);
    });
    return false;
  });
}); 

//加载JS
$(document).ready(function() {
  $(&#39;#letter-c a&#39;).click(function() {
    $.getScript(&#39;c.js&#39;);
    return false;
  });
}); 

//加载XML
$(document).ready(function() {
  $(&#39;#letter-d a&#39;).click(function() {
    $.get(&#39;d.xml&#39;, function(data) {
      $(&#39;#dictionary&#39;).empty();
      $(data).find(&#39;entry&#39;).each(function() {
        var $entry = $(this);
        var html = &#39;&amp;lt;div class=&quot;entry&quot;&amp;gt;&#39;;
        html += &#39;&amp;lt;h3 class=&quot;term&quot;&amp;gt;&#39; + $entry.attr(&#39;term&#39;);
          html += &#39;&amp;lt;/h3&amp;gt;&#39;;
        html += &#39;&amp;lt;div class=&quot;part&quot;&amp;gt;&#39; + $entry.attr(&#39;part&#39;);
          html += &#39;&amp;lt;/div&amp;gt;&#39;;
        html += &#39;&amp;lt;div class=&quot;definition&quot;&amp;gt;&#39;;
        html += $entry.find(&#39;definition&#39;).text();
        var $quote = $entry.find(&#39;quote&#39;);
        if ($quote.length) {
          html += &#39;&amp;lt;div class=&quot;quote&quot;&amp;gt;&#39;;
          $quote.find(&#39;line&#39;).each(function() {
            html += &#39;&amp;lt;div class=&quot;quote-line&quot;&amp;gt;&#39;;
              html += $(this).text() + &#39;&amp;lt;/div&amp;gt;&#39;;
          });
          if ($quote.attr(&#39;author&#39;)) {
            html += &#39;&amp;lt;div class=&quot;quote-author&quot;&amp;gt;&#39;;
              html += $quote.attr(&#39;author&#39;) + &#39;&amp;lt;/div&amp;gt;&#39;;
          }
          html += &#39;&amp;lt;/div&amp;gt;&#39;;
        }
        html += &#39;&amp;lt;/div&amp;gt;&#39;;
        html += &#39;&amp;lt;/div&amp;gt;&#39;;
        $(&#39;#dictionary&#39;).append($(html));
      });
    });
    return false;
  });
}); 

//使用get请求PHP
$(document).ready(function() {
  $(&#39;#letter-e a&#39;).click(function() {
    var requestData = {term: $(this).text()};
    $.get(&#39;e.php&#39;, requestData, function(data) {
      $(&#39;#dictionary&#39;).html(data);
    });
    return false;
  });
});

//使用POST请求
$(document).ready(function() {
  $(&#39;#letter-e a&#39;).click(function() {
    var requestData = {term: $(this).text()};
    $.post(&#39;e.php&#39;, requestData, function(data) {
      $(&#39;#dictionary&#39;).html(data);
    });
    return false;
  });
}); 
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 06 Jan 2015 00:00:00 +0800</pubDate>
        <link>/2015/01/06/jquery.html</link>
        <guid isPermaLink="true">/2015/01/06/jquery.html</guid>
        
        
      </item>
    
      <item>
        <title>CSS选择器</title>
        <description>&lt;h1 id=&quot;css&quot;&gt;CSS选择器&lt;/h1&gt;
&lt;p&gt;##先简单介绍几种追简单的选择器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//元素选择器
html {
	color:black;
	}
	
//选择器分组
h1 ,h2 {
  font: 28px Verdana;
  color: blue;
  background: red;
  }

//派生选择器，也可以叫做上下文选择器，下面说的是列表中的strong
li strong {
    font-style: italic;
    font-weight: normal;
  }
  
//id选择器，各种选择器可以组合使用
#red {
	color:red;
	}
#sidebar p {
	font-style: italic;
	text-align: right;
	margin-top: 0.5em;
	}

//类选择器
.center {
	text-align: center
	}
td.fancy {
	color: #f60;
	background: #666;
	}
  
//通配符选择器
* {
  color:red;
  }

//属性选择器
[lang|=en] 
{ 
  color:red; 
}
input[type=&quot;text&quot;]
{
  width:150px;
  display:block;
  margin-bottom:10px;
  background-color:yellow;
  font-family: Verdana, Arial;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性选择器的语法如下&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;选择器&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute]&lt;/td&gt;
      &lt;td&gt;用于选取带有指定属性的元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute=value]&lt;/td&gt;
      &lt;td&gt;用于选取带有指定属性和值的元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute~=value]&lt;/td&gt;
      &lt;td&gt;用于选取属性值中包含指定词汇的元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute|=value]&lt;/td&gt;
      &lt;td&gt;用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute^=value]&lt;/td&gt;
      &lt;td&gt;匹配属性值以指定值开头的每个元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute$=value]&lt;/td&gt;
      &lt;td&gt;匹配属性值以指定值结尾的每个元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute*=value]&lt;/td&gt;
      &lt;td&gt;匹配属性值中包含指定值的每个元素。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section&quot;&gt;高级语法&lt;/h2&gt;
&lt;p&gt;属性选择器可以同时选择多个属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a[href][title]
{
color:red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有一点需要注意的是，派生选择器无法确定几层的子类，也就是说所有包括的子类都将要被选择，所以这里还可以使用子类选择器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;h1 &amp;gt; strong {
	color:red;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选了子类，那么我们想选择他的邻居怎么办，对使用相邻兄弟选择器（Adjacent sibling selector），可选择紧接在另一元素后的元素，且二者有相同父元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;h1 + p {
	margin-top:50px;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后要说就是伪类的概念，CSS 伪类用于向某些选择器添加特殊的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;伪类的语法：
selector : pseudo-class {property: value}
CSS 类也可与伪类搭配使用。
selector.class : pseudo-class {property: value}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;CSS&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;:active&lt;/td&gt;
      &lt;td&gt;向被激活的元素添加样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:focus&lt;/td&gt;
      &lt;td&gt;向拥有键盘输入焦点的元素添加样式。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:hover&lt;/td&gt;
      &lt;td&gt;当鼠标悬浮在元素上方时，向元素添加样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:link&lt;/td&gt;
      &lt;td&gt;向未被访问的链接添加样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:visited&lt;/td&gt;
      &lt;td&gt;向已被访问的链接添加样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:first-child&lt;/td&gt;
      &lt;td&gt;向元素的第一个子元素添加样式。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:lang&lt;/td&gt;
      &lt;td&gt;向带有指定 lang 属性的元素添加样式。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;与伪类相似的还有伪元素，CSS 伪元素用于向某些选择器设置特殊效果。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;CSS&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;:first-letter&lt;/td&gt;
      &lt;td&gt;向文本的第一个字母添加特殊样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:first-line&lt;/td&gt;
      &lt;td&gt;向文本的首行添加特殊样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:before&lt;/td&gt;
      &lt;td&gt;在元素之前添加内容。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:after&lt;/td&gt;
      &lt;td&gt;在元素之后添加内容。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Mon, 05 Jan 2015 00:00:00 +0800</pubDate>
        <link>/2015/01/05/css-selected.html</link>
        <guid isPermaLink="true">/2015/01/05/css-selected.html</guid>
        
        
      </item>
    
      <item>
        <title>Server知识</title>
        <description>&lt;p&gt;构建一个大型的网站面临着几个重要的问题需要去解决：大量的访问 访问的速度 监控 和 数据库存储&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;大量的访问&lt;/h2&gt;
&lt;p&gt;这里涉及到了两个概念 就是网络的 负载均衡 和 容余&lt;br /&gt;
说道负载均衡，其实就是说有一个东西去控制外部的访问到不同的服务器，使得所有的服务器都可以拥有相似的负载，不会造成某一个服务器拥有过多的负载，它的实现方法其实也很简单，就是通过某些物理线路，路由器，虚拟服务器，或者软件进行分流，这里还用到了一些地址重定向的技术&lt;br /&gt;
在这里，依次分派不同的任务到服务器叫做轮训&lt;br /&gt;
另一个知识点就是容余，他的概念就是说每台激活的服务器可能都拥有一个集群，所谓集群就是没几个服务器集成的群组，在同一时间内只有一个服务器处于激活状态，其他属于睡眠状态，而一旦激活的服务器宕机，那么睡眠的服务器就会被启动&lt;br /&gt;
通过这样的两个技术，就基本实现了资源的最大利用&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数据库存储&lt;/h2&gt;
&lt;p&gt;现在分两种数据库，SQL和NoSQL,其中SQL的代表是MySQL，NoSQL的代表是Mongo&lt;br /&gt;
上面说到了负载均衡和容余，其实在数据库系统中也有类似的机制，其中MySQL拥有一种叫做主从服务器的机制，就是说，主服务器进行数据库增添改，然后会通过一种bin log的日志把数据同步到从属服务器中然后，所有的搜索命令会使用从属服务器去处理&lt;br /&gt;
还有一个重要的问题就是数据库搜索加速，一种做法就是索引，或者使用外部的索引系统，二就是实现分表分区，所谓分表就是把数据分在不同的表内，但是缺点就是需要修改SQL命令，而分区的做法就是逻辑不变，但是数据库系统自动帮你去在多个表内进行搜索&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;如何进行网络加速&lt;/h2&gt;
&lt;p&gt;利用代理缓存，代理服务器中可能拥有某些服务，这些服务器中就拥有了缓存池，能够缓存一些静态文件，当然另一种最基本的代理的加速就是代理服务器去帮助用户向主服务器获取数据&lt;br /&gt;
在上面的情况中，主服务器需要做的就是把一些动态文件静态化，便于代理缓存，具体的实现方法其实就是使用一些模板，或者框架，例如PHP的ThinkPHP&lt;br /&gt;
另一种加速方式就是把某些搜索或者IO变成内存级别的搜索，这里用到了一种meocache的技术，这种技术的优点就是数据都在内存中，缺点就是没有存储到本地，解决方案可以使用redies等NoSQL &lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;最后是监控&lt;/h2&gt;
&lt;p&gt;说实话这里实在是没有什么经验，以后如果做了一些，再来补充吧&lt;/p&gt;
</description>
        <pubDate>Wed, 31 Dec 2014 00:00:00 +0800</pubDate>
        <link>/2014/12/31/server-konwledge.html</link>
        <guid isPermaLink="true">/2014/12/31/server-konwledge.html</guid>
        
        
      </item>
    
      <item>
        <title>Jekyll的使用</title>
        <description>&lt;h1 id=&quot;jekyll&quot;&gt;Jekyll&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;jekyll 安装  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jekyll还有两个重要的命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll build  
# =&amp;gt; 根据当前目录里的内容生成静态网页，网页存放到目录 ./_site
$ jekyll serve
# =&amp;gt; 启动服务端部署_site内的网站到 http://localhost:4000,你可以在浏览器里输入这个URL来预览你的博客网站的效果
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后再说说jeyll的文档结构 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── _config.yml  //jekyll的配置文件，jekyll的很多参数可以在输入命令行时直接输入，也可以写入配置文件，简化繁琐的命令输入过程。
├── _drafts  //这个文件夹里面是用来存放草稿的，里面的文件不需要在文件名中加入固定格式的日期前缀。

|   ├── begin-with-the-crazy-ideas.textile  
|   └── on-simplicity-in-technology.markdown  
├── _includes  //这里面可以放置一些可重用的模块来加速开发，你可以方便的将里面的内容在多个文件里复用。譬如你也可以在多个页面中加入一块固定的模块，这个模块存放在文件_includes/file.ext，只需要在文件中插入liquid标签： % include file.ext %] 。
|   ├── footer.html
|   └── header.html
├── _layouts    //这个目录存放的是一些布局文件，我们的post文章里面可以使用YAML前缀格式来设置我们使用的布局。我们可以使用liquid标签  在我们的web页中插入内容。
|   ├── default.html
|   └── post.html
├── _posts    //这里是用来放置你的文章的，里面的文件需要加入日期前缀，格式为： YEAR-MONTH-DAY-title.MARKUP 。前面的日期格式是固定的，jekyll可以自动提取出文件名中的日期前缀用来标识文件发布的日期，这个日期可以用来排序，分类，显示等。

|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile
|   └── 2009-04-26-barcamp-boston-4-roundup.textile
├── _site    jekyll默认会将jekyll项目中的内容生成静态网页放到这个目录中，这个目录是可以自定义的，可以写到配置文件_config.yml中。默认这个目录会加入.gitignore文件中，里面的内容不会上传到github，github page会自动根据你上传的jekyll项目生成对应的网页，而不会直接展示你自己本地生成的网页。

└── index.html   //默认的主页文件，可以在文件头部加入YAML区域，内容中也可以加入Markdown等格式的内容。这个文件也会被jekyll转换成对应网页，不会直接显示你定义的内容。文件后缀可以是：.html, .markdown, .md, .textile 等。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##发布&lt;/p&gt;

&lt;p&gt;那么在整个需要post的文档前面 我们一般都是添加 YAML front matter 来进行记录或者预处理一些东西，格式如下  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: Blogging Like a Hacker
---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里我们可以自定义一些属性，如title，但是还是有一些全局的属性&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;layout&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;设置这个变量可以指定使用某个指定的布局文件。布局文件不需要加文件名后缀。布局文件需要放到_layouts文件夹中。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;permalink&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;发布的post的url默认会是/year/month/day/title.html的格式，用户可以设置这个变量来设置静态URL。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;published&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;post设置这个变量为false，那么这个post在产生网页时不会发布。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;category，categories&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Instead of placing posts inside of folders, you can specify one or more categories that the post belongs to. When the site is generated the post will act as though it had been set with these categories normally. 类别(Categories)可以使用YAML列表的形式或者使用空格分隔的字符串形式。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;tags&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;与分类(categories)类似，可以定义一个或多个标签(tags)，同样的也可以用YAML列表形式或空格分隔的字符串形式&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;说完了post文件的头，那么我们就可以说说我们的博客本身了
首先这类的文件可以分成两种，markdown 和 html， 命名如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2011-12-31-new-years-eve-is-awesome.md
2012-09-12-how-to-write-a-blog.textile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###内容格式&lt;br /&gt;
所有的博客文件必须以YAML front-matter开头。然后剩余部分用户就可以自己选择使用哪种格式了。Jekyll提供了两种流行的内容标记格式：Markdown和Textile。每种格式都有自己的标记内容的方法，你需要熟悉这两种格式并选择你自己需要的格式。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;在文章中包含图片及其他资源&lt;/h3&gt;
&lt;p&gt;有时候用户需要在post中添加图片，下载文件或其他内容。因为语法的不同，Markdown和Textlie的链接的表达方式不同，因此存储图片，二进制文件等的位置也有所不同。&lt;/p&gt;

&lt;p&gt;由于Jekyll的灵活性，有很多不同的解决方案来解决这个问题。通用的解决方案是在根目录创建一个文件夹，例如assets或者downloads，图片，下载文件和其他资源就可以放到这个目录下。这样，post中就可以以根目录为起始路径来链接到这些资源文件。当然，这要依赖与你的网站的（子）域名和路径的配置。下面给出一些利用site.url变量来实现的链接(使用Markdown)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;… which is shown in the screenshot below:
![My helpful screenshot](/assets/screenshot.jpg)
… you can [get the PDF](/assets/mydoc.pdf) directly.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;post还可以使用一些属性 url,title,excerpt&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;代码高亮&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
&amp;lt;div class=&quot;highlight&quot;&amp;gt;&amp;lt;pre&amp;gt;&amp;lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&amp;gt;&amp;lt;span class=&quot;k&quot;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;nf&quot;&amp;gt;show&amp;lt;/span&amp;gt;
  &amp;lt;span class=&quot;vi&quot;&amp;gt;@widget&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;o&quot;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;no&quot;&amp;gt;Widget&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;p&quot;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;n&quot;&amp;gt;params&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;[&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ss&quot;&amp;gt;:id&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;]&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;p&quot;&amp;gt;)&amp;lt;/span&amp;gt;
  &amp;lt;span class=&quot;n&quot;&amp;gt;respond_to&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;k&quot;&amp;gt;do&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;o&quot;&amp;gt;|&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;nb&quot;&amp;gt;format&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;|&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;nb&quot;&amp;gt;format&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;n&quot;&amp;gt;html&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;c1&quot;&amp;gt;# show.html.erb&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;nb&quot;&amp;gt;format&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;n&quot;&amp;gt;json&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;p&quot;&amp;gt;{&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;n&quot;&amp;gt;render&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;ss&quot;&amp;gt;json&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;p&quot;&amp;gt;:&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;vi&quot;&amp;gt;@widget&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;p&quot;&amp;gt;}&amp;lt;/span&amp;gt;
  &amp;lt;span class=&quot;k&quot;&amp;gt;end&amp;lt;/span&amp;gt;
&amp;lt;span class=&quot;k&quot;&amp;gt;end&amp;lt;/span&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;/div&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##网站的组织形式&lt;br /&gt;
很多网站默认启动服务会找HTML文件index.html作为网站的首页来展示。Jekyll也一样，除非你自己在web服务器上配置了其他文件，否则Jekyll也会默认将index.html文件作为首页。&lt;/p&gt;

&lt;p&gt;在首页中使用布局layouts
Jekyll项目中的任何HTML文件都可以使用布局(layouts)和包含文件(includes)，包括首页。一些通用的元素，例如头部和尾部，可以抽取出来做到布局中，这样方便开发，网站的风格也能统一。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;额外的页面放置在哪？&lt;/h3&gt;

&lt;p&gt;在哪里放置HTML页面文件取决与你想让你的页面如何工作。有两种主要的创建页面的方式：&lt;br /&gt;
放置HTML文件到网站根目录，每个页面单独命名。
在网站根目录为每个页面创建一个单独命名的文件夹，每个文件夹里放置一个名为index.html的文件&lt;br /&gt;
这两种方式都能很好的工作，也可以混合使用，唯一的不同就是最终访问路径URL的不同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes/
|-- _layouts/
|-- _posts/
|-- _site/
|-- about.html    # =&amp;gt; http://yoursite.com/about.html
|-- index.html    # =&amp;gt; http://yoursite.com/
└── contact.html  # =&amp;gt; http://yoursite.com/contact.html

.
├── _config.yml
├── _includes/
├── _layouts/
├── _posts/
├── _site/
├── about/
|   └── index.html  # =&amp;gt; http://yoursite.com/about/
├── contact/
|   └── index.html  # =&amp;gt; http://yoursite.com/contact/
└── index.html      # =&amp;gt; http://yoursite.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;变量&lt;/h2&gt;
&lt;p&gt;全局变量&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;_config.yml文件中配置的全网站范围的信息和配置项。更详细的内容参考下面。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page专用的信息以及YAML Front Matter。用户在YAML front matter中设置的自定义变量也可以在这里使用。更详细的内容参考下面。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;content&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在布局文件中，post和page的内容会被封装起来。这个变量在post和page文件中没有定义。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;这个变量在变量paginate变量被设置后才产生作用。详细内容参考Pagination&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Site变量 &lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.time&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;当前时间(当你运行jekyll时)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.pages&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;所有pages的列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.posts&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;所有posts的列表，按时间顺序倒序排列。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.related_posts&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;如果当前处理的页面是post，则这个变量包含了至多十个的相关的posts的列表。 By default, these are low quality but fast to compute. For high quality but slow to compute results, run the jekyll command with the –lsi (latent semantic indexing) option.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.categories.CATEGORY&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;所有指定分类CATEGORY中的posts的列表。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.tags.TAG&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;所有包含标签TAG的posts的列表。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.[CONFIGURATION_DATA]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;所有通过命令行以及通过_config.yml设置的变量都可以通过变量site来访问。例如，在配置文件中设置了url:http://mysite.com，那么在posts和pages中可以通过变量site.url来使用设置的变量值。在watch模式下，Jekyll并不会去解析_config.yml文件，只在Jeykll服务启动的时候才会解析，因此如果你改变了配置项的值，你需要重新启动Jekyll来使改变生效。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Page变量&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.content&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;The un-rendered content of the Page.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.title&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page的标题&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.excerpt&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;The un-rendered excerpt of the Page.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.url&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;post的URL，不包含域名，以”/”开头。例如：/2008/12/14/my-post.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.date&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;指定的日期。这个变量可以在post的front matter中指定一个新的日期/时间来覆盖已有的日期，格式为：YYYY-MM-DD HH:MM:SS(假定是UTC世界标准时间)，或者：YYYY-MM-DD HH:MM:SS +/-TTTT(使用一个相对UTC的偏移量来指定时区，例如：2008-12-14 10:30:00 +0900）。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.id&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;post的唯一标识ID(对RSS feeds有用)。例如：/2008/12/14/my-post。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.categories&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;post所属的类别的列表。类别(categories)派生于_posts之上的目录结构。例如，一个设置page.categories变量为[‘work, ‘code’]的post将位于/work/code/_posts/2008-12-24-closures.md。这些可以在YAML Front Matter中进行设置。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.tags&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;post所属的tags的列表。可以在YAML Front Matter中进行设置。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.path&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;原生post或者page文件的路径。用法实例：链接到github上的page或者post的源文件。可以在YAML Front Matter中覆盖这个变量。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Paginator&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginagor.per_page&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;每个page页面包含的posts数目。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.posts&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page页面可用的posts&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.total_posts&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;posts的总数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.total_pages&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pages的总数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.page&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;当前page页面的编号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.previous_page&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;前一个page页面的编号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.previous_page_path&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;前一个page页面的path路径&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.next_page&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;后一个page页面的编号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.next_page_path&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;后一个page页面的path路径&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Fri, 26 Dec 2014 00:00:00 +0800</pubDate>
        <link>/2014/12/26/yekyll-document.html</link>
        <guid isPermaLink="true">/2014/12/26/yekyll-document.html</guid>
        
        
      </item>
    
  </channel>
</rss>
