<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>place_your_blog_title_here</title>
    <link>place_your_blog_url_here</link>
    <atom:link href="place_your_blog_url_here/rss.xml" rel="self" type="application/rss+xml" />
    <description>place_your_blog_description_here</description>
    <language>place_your_blog_language_here</language>
    <pubDate>Thu, 08 Jan 2015 12:45:57 +0800</pubDate>
    <lastBuildDate>Thu, 08 Jan 2015 12:45:57 +0800</lastBuildDate>

    
    <item>
      <title>JQuery 学习笔记</title>
      <link>place_your_blog_url_here/2015/01/06/jquery.html</link>
      <pubDate>06 Jan 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2015/01/06/jquery</guid>
      <description>&lt;h1 id=&quot;jquery-&quot;&gt;JQuery 学习笔记&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;选择器&lt;/h2&gt;
&lt;p&gt;使用$()选择JQuery对象，他的选择器与CSS的选择器十分的类似&lt;br /&gt;
当然JQuery拥有一些自定义的选择符号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:eq(1)      //第几个元素
:odd    	//偶数的元素
:even       //基数的元素
:nth-child()    //这个选择符相对于元素的父元素而非当前选择的所有元素来计算位置，它可以接受数值、odd或even作为参数
:contains()     //这个区分大小
之后还有一系列基于表单的选择符

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在选择后，其实选择的是一个数组，那么其实可以通过下面的方法获取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myTag = $(&#39;#myTag&#39;)[0].tagName
var myTags = $(&#39;#myTag&#39;).get(0).tagName
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;事件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$(document).ready()    //页面加载后调用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绑定事件使用bind()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function() {
  $(&#39;#switcher-large&#39;).bind(&#39;click&#39;, function() {
    $(&#39;body&#39;).addClass(&#39;large&#39;);
  });
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用$(this)在function中 代表这个对象&lt;br /&gt;
下面是一些事件&lt;br /&gt;
&lt;img src=&quot;../_postsImages/jquery1.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
下面再说一些事件流程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 事件目标
// 未完成的代码
$(document).ready(function() {
  $(&#39;#switcher&#39;).click(function(event) {
    if (event.target == this) {
      $(&#39;#switcher button&#39;).toggleClass(&#39;hidden&#39;);
    }
  });
}); 

// 停止事件传播
$(document).ready(function() {
  $(&#39;#switcher&#39;).click(function(event) {
    $(&#39;#switcher button&#39;).toggleClass(&#39;hidden&#39;);
  });
});

$(document).ready(function() {
  $(&#39;#switcher-default&#39;).addClass(&#39;selected&#39;);

  $(&#39;#switcher button&#39;).click(function(event) {
    var bodyClass = this.id.split(&#39;-&#39;)[1];

    $(&#39;body&#39;).removeClass().addClass(bodyClass);

    $(&#39;#switcher button&#39;).removeClass(&#39;selected&#39;);
    $(this).addClass(&#39;selected&#39;);
    event.stopPropagation();
  });
}); 

// 判断this属性
$(document).ready(function() {
  $(&#39;#switcher&#39;).click(function(event) {
    if ($(event.target).is(&#39;button&#39;)) {  //使用 is 判断
      var bodyClass = event.target.id.split(&#39;-&#39;)[1];

      $(&#39;body&#39;).removeClass().addClass(bodyClass);

      $(&#39;#switcher button&#39;).removeClass(&#39;selected&#39;);
      $(event.target).addClass(&#39;selected&#39;);
      event.stopPropagation();
    }
  });
}); 

// 事件委托 ，有很多种方法 比如live,die等等
$(&#39;#switcher button&#39;).live(&#39;click&#39;, function() {
  var bodyClass = event.target.id.split(&#39;-&#39;)[1];

  $(&#39;body&#39;).removeClass().addClass(bodyClass);

  $(&#39;#switcher button&#39;).removeClass(&#39;selected&#39;);
  $(this).addClass(&#39;selected&#39;);
}); 

// 模仿用户
$(document).ready(function() {
  $(&#39;#switcher&#39;).trigger(&#39;click&#39;);
}); 

//从键盘输入
$(document).ready(function() {
  var triggers = {
    D: &#39;default&#39;,
    N: &#39;narrow&#39;,
    L: &#39;large&#39;
  };

  $(document).keyup(function(event) {
    var key = String.fromCharCode(event.keyCode);
    if (key in triggers) {
      $(&#39;#switcher-&#39; + triggers[key]).click();
    }
  });
}); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;样式与动画&lt;/h2&gt;
&lt;p&gt;首先 .css() 这个方法 继承了getter和setter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 单个属性及其值
.css(&#39;property&#39;, &#39;value&#39;)
// 属性-值对构成
.css({
  property1: &#39;value1&#39;,
  &#39;property-2&#39;: &#39;value2&#39;
}) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用hide和show现实和隐藏元素，其中还可以使用’slow’、’normal’和’fast’来当做速度的参数&lt;br /&gt;
我们使用fadeIn和fadeOut实现淡出和淡入 &lt;br /&gt;
使用和slideDown和slideUp实现划上和滑下&lt;br /&gt;
jquery还可以使用。animate()自定义动画，这里面有可以设置该标的元素，速度，回调等，是一个并发的方法，&lt;br /&gt;
如果我们需要一个队列效果执行的动画呢，可以连缀多个animate()动画&lt;br /&gt;
如果在速度选项中添加 queue:false，则不是使用队列触发&lt;/p&gt;

&lt;h2 id=&quot;dom&quot;&gt;DOM操作&lt;/h2&gt;
&lt;p&gt;我们可以使用addClass()和removeClass()来添加Class，对于其他的一些属性，我们则可以通过attr()和removeAttr()来添加和删除。&lt;br /&gt;
使用attr赋值的时候其实可以不传值，传递一个function这样每次都会调用这个方法&lt;br /&gt;
在jQuery可以使用.prop获取属性   &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 取得 &quot;checked&quot; 属性的当前值
var currentlyChecked = $(&#39;.my-checkbox&#39;).prop(&#39;checked&#39;);

// 设置 &quot;checked&quot; 属性的值
$(&#39;.my-checkbox&#39;).prop(&#39;checked&#39;, false); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###添加，移动元素
(1) .insertBefore()在现有元素外部、之前添加内容；&lt;br /&gt;
(2) .prependTo()在现有元素内部、之前添加内容；&lt;br /&gt;
(3) .appendTo()在现有元素内部、之后添加内容；&lt;br /&gt;
(4) .insertAfter()在现有元素外部、之后添加内容。&lt;br /&gt;
与之对应的还有反向插入方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function() {
  $(&#39;&amp;lt;a href=&quot;#top&quot;&amp;gt;back to top&amp;lt;/a&amp;gt;&#39;).insertAfter(&#39;div.chapterp&#39;);
  $(&#39;&amp;lt;a id=&quot;top&quot;&amp;gt;&amp;lt;/a&amp;gt;&#39;).prependTo(&#39;body&#39;);
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;移动元素和插入元素相似，只不过是选择已经存在的元素  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//包装元素
$(document).ready(function() {
  $(&#39;span.footnote&#39;)
    .insertBefore(&#39;#footer&#39;)
    .wrapAll(&#39;&amp;lt;ol id=&quot;notes&quot;&amp;gt;&amp;lt;/ol&amp;gt;&#39;) //我们使用.wrapAll()把所有脚注都包含在一个&amp;lt;ol&amp;gt;中
    .wrap(&#39;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&#39;); //使用.wrap()将每一个脚注分别包装在自己的&amp;lt;li&amp;gt;中
});

//复制
$(&#39;123&#39;).clone()
$(&#39;123&#39;).clone(true) //同时复制事件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###简单总结
对于jQuery提供的大量DOM操作方法，应该根据要完成的任务和元素的位置作出不同的选择。本章只介绍了一部分DOM操作方法，但其他方法的使用与这些方法类似；第12章还将更全面地讨论DOM操作方法。下面，我们简单地归纳出一些方法，这些方法几乎能够在任何情况下，完成任何任务。&lt;br /&gt;
(1) 要在HTML中创建新元素，使用$()函数。&lt;br /&gt;
(2) 要在每个匹配的元素中插入新元素，使用：&lt;br /&gt;
append()&lt;br /&gt;
appendTo()&lt;br /&gt;
prepend()
prependTo()&lt;br /&gt;
(3) 要在每个匹配的元素相邻的位置上插入新元素，使用：&lt;br /&gt;
after()&lt;br /&gt;
insertAfter()&lt;br /&gt;
before()&lt;br /&gt;
insertBefore()&lt;br /&gt;
(4) 要在每个匹配的元素外部插入新元素，使用： 
wrap()&lt;br /&gt;
wrapAll()&lt;br /&gt;
wrapInner()&lt;br /&gt;
(5) 要用新元素或文本替换每个匹配的元素，使用：&lt;br /&gt;
html()&lt;br /&gt;
text()&lt;br /&gt;
replaceAll()&lt;br /&gt;
replaceWith()&lt;br /&gt;
(6) 要移除每个匹配的元素中的元素，使用：&lt;br /&gt;
empty()&lt;br /&gt;
(7) 要从文档中移除每个匹配的元素及其后代元素，但不实际删除它们，使用：&lt;br /&gt;
remove()&lt;br /&gt;
detach()  &lt;/p&gt;

&lt;h2 id=&quot;ajax&quot;&gt;AJAX的使用&lt;/h2&gt;
&lt;p&gt;在下面的事件中返回false,防止跳转&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//简单加载html
$(document).ready(function() {
  $(&#39;#letter-a a&#39;).click(function() {
    $(&#39;#dictionary&#39;).load(&#39;a.html&#39;);
    return false;
  });
}); 

//加载JSON
$(document).ready(function() {
  $(&#39;#letter-b a&#39;).click(function() {
    $.getJSON(&#39;b.json&#39;, function(data) {
      var html = &#39;&#39;;
      $.each(data, function(entryIndex, entry) {
        html += &#39;&amp;lt;div class=&quot;entry&quot;&amp;gt;&#39;;
        html += &#39;&amp;lt;h3 class=&quot;term&quot;&amp;gt;&#39; + entry.term + &#39;&amp;lt;/h3&amp;gt;&#39;;
        html += &#39;&amp;lt;div class=&quot;part&quot;&amp;gt;&#39; + entry.part + &#39;&amp;lt;/div&amp;gt;&#39;;
        html += &#39;&amp;lt;div class=&quot;definition&quot;&amp;gt;&#39;;
        html += entry.definition;
        html += &#39;&amp;lt;/div&amp;gt;&#39;;
        html += &#39;&amp;lt;/div&amp;gt;&#39;;
      });
      $(&#39;#dictionary&#39;).html(html);
    });
    return false;
  });
}); 

//加载JS
$(document).ready(function() {
  $(&#39;#letter-c a&#39;).click(function() {
    $.getScript(&#39;c.js&#39;);
    return false;
  });
}); 

//加载XML
$(document).ready(function() {
  $(&#39;#letter-d a&#39;).click(function() {
    $.get(&#39;d.xml&#39;, function(data) {
      $(&#39;#dictionary&#39;).empty();
      $(data).find(&#39;entry&#39;).each(function() {
        var $entry = $(this);
        var html = &#39;&amp;lt;div class=&quot;entry&quot;&amp;gt;&#39;;
        html += &#39;&amp;lt;h3 class=&quot;term&quot;&amp;gt;&#39; + $entry.attr(&#39;term&#39;);
          html += &#39;&amp;lt;/h3&amp;gt;&#39;;
        html += &#39;&amp;lt;div class=&quot;part&quot;&amp;gt;&#39; + $entry.attr(&#39;part&#39;);
          html += &#39;&amp;lt;/div&amp;gt;&#39;;
        html += &#39;&amp;lt;div class=&quot;definition&quot;&amp;gt;&#39;;
        html += $entry.find(&#39;definition&#39;).text();
        var $quote = $entry.find(&#39;quote&#39;);
        if ($quote.length) {
          html += &#39;&amp;lt;div class=&quot;quote&quot;&amp;gt;&#39;;
          $quote.find(&#39;line&#39;).each(function() {
            html += &#39;&amp;lt;div class=&quot;quote-line&quot;&amp;gt;&#39;;
              html += $(this).text() + &#39;&amp;lt;/div&amp;gt;&#39;;
          });
          if ($quote.attr(&#39;author&#39;)) {
            html += &#39;&amp;lt;div class=&quot;quote-author&quot;&amp;gt;&#39;;
              html += $quote.attr(&#39;author&#39;) + &#39;&amp;lt;/div&amp;gt;&#39;;
          }
          html += &#39;&amp;lt;/div&amp;gt;&#39;;
        }
        html += &#39;&amp;lt;/div&amp;gt;&#39;;
        html += &#39;&amp;lt;/div&amp;gt;&#39;;
        $(&#39;#dictionary&#39;).append($(html));
      });
    });
    return false;
  });
}); 

//使用get请求PHP
$(document).ready(function() {
  $(&#39;#letter-e a&#39;).click(function() {
    var requestData = {term: $(this).text()};
    $.get(&#39;e.php&#39;, requestData, function(data) {
      $(&#39;#dictionary&#39;).html(data);
    });
    return false;
  });
});

//使用POST请求
$(document).ready(function() {
  $(&#39;#letter-e a&#39;).click(function() {
    var requestData = {term: $(this).text()};
    $.post(&#39;e.php&#39;, requestData, function(data) {
      $(&#39;#dictionary&#39;).html(data);
    });
    return false;
  });
}); 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CSS选择器</title>
      <link>place_your_blog_url_here/2015/01/05/css-selected.html</link>
      <pubDate>05 Jan 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2015/01/05/css-selected</guid>
      <description>&lt;h1 id=&quot;css&quot;&gt;CSS选择器&lt;/h1&gt;
&lt;p&gt;##先简单介绍几种追简单的选择器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//元素选择器
html {
	color:black;
	}
	
//选择器分组
h1 ,h2 {
  font: 28px Verdana;
  color: blue;
  background: red;
  }

//派生选择器，也可以叫做上下文选择器，下面说的是列表中的strong
li strong {
    font-style: italic;
    font-weight: normal;
  }
  
//id选择器，各种选择器可以组合使用
#red {
	color:red;
	}
#sidebar p {
	font-style: italic;
	text-align: right;
	margin-top: 0.5em;
	}

//类选择器
.center {
	text-align: center
	}
td.fancy {
	color: #f60;
	background: #666;
	}
  
//通配符选择器
* {
  color:red;
  }

//属性选择器
[lang|=en] 
{ 
  color:red; 
}
input[type=&quot;text&quot;]
{
  width:150px;
  display:block;
  margin-bottom:10px;
  background-color:yellow;
  font-family: Verdana, Arial;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性选择器的语法如下&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;选择器&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute]&lt;/td&gt;
      &lt;td&gt;用于选取带有指定属性的元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute=value]&lt;/td&gt;
      &lt;td&gt;用于选取带有指定属性和值的元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute~=value]&lt;/td&gt;
      &lt;td&gt;用于选取属性值中包含指定词汇的元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute|=value]&lt;/td&gt;
      &lt;td&gt;用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute^=value]&lt;/td&gt;
      &lt;td&gt;匹配属性值以指定值开头的每个元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute$=value]&lt;/td&gt;
      &lt;td&gt;匹配属性值以指定值结尾的每个元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute*=value]&lt;/td&gt;
      &lt;td&gt;匹配属性值中包含指定值的每个元素。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section&quot;&gt;高级语法&lt;/h2&gt;
&lt;p&gt;属性选择器可以同时选择多个属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a[href][title]
{
color:red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有一点需要注意的是，派生选择器无法确定几层的子类，也就是说所有包括的子类都将要被选择，所以这里还可以使用子类选择器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;h1 &amp;gt; strong {
	color:red;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选了子类，那么我们想选择他的邻居怎么办，对使用相邻兄弟选择器（Adjacent sibling selector），可选择紧接在另一元素后的元素，且二者有相同父元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;h1 + p {
	margin-top:50px;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后要说就是伪类的概念，CSS 伪类用于向某些选择器添加特殊的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;伪类的语法：
selector : pseudo-class {property: value}
CSS 类也可与伪类搭配使用。
selector.class : pseudo-class {property: value}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;CSS&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;:active&lt;/td&gt;
      &lt;td&gt;向被激活的元素添加样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:focus&lt;/td&gt;
      &lt;td&gt;向拥有键盘输入焦点的元素添加样式。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:hover&lt;/td&gt;
      &lt;td&gt;当鼠标悬浮在元素上方时，向元素添加样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:link&lt;/td&gt;
      &lt;td&gt;向未被访问的链接添加样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:visited&lt;/td&gt;
      &lt;td&gt;向已被访问的链接添加样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:first-child&lt;/td&gt;
      &lt;td&gt;向元素的第一个子元素添加样式。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:lang&lt;/td&gt;
      &lt;td&gt;向带有指定 lang 属性的元素添加样式。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;与伪类相似的还有伪元素，CSS 伪元素用于向某些选择器设置特殊效果。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;CSS&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;:first-letter&lt;/td&gt;
      &lt;td&gt;向文本的第一个字母添加特殊样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:first-line&lt;/td&gt;
      &lt;td&gt;向文本的首行添加特殊样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:before&lt;/td&gt;
      &lt;td&gt;在元素之前添加内容。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:after&lt;/td&gt;
      &lt;td&gt;在元素之后添加内容。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
    </item>
    
    <item>
      <title>Server知识</title>
      <link>place_your_blog_url_here/2014/12/31/server-konwledge.html</link>
      <pubDate>31 Dec 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/12/31/server-konwledge</guid>
      <description>&lt;p&gt;构建一个大型的网站面临着几个重要的问题需要去解决：大量的访问 访问的速度 监控 和 数据库存储&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;大量的访问&lt;/h2&gt;
&lt;p&gt;这里涉及到了两个概念 就是网络的 负载均衡 和 容余&lt;br /&gt;
说道负载均衡，其实就是说有一个东西去控制外部的访问到不同的服务器，使得所有的服务器都可以拥有相似的负载，不会造成某一个服务器拥有过多的负载，它的实现方法其实也很简单，就是通过某些物理线路，路由器，虚拟服务器，或者软件进行分流，这里还用到了一些地址重定向的技术&lt;br /&gt;
在这里，依次分派不同的任务到服务器叫做轮训&lt;br /&gt;
另一个知识点就是容余，他的概念就是说每台激活的服务器可能都拥有一个集群，所谓集群就是没几个服务器集成的群组，在同一时间内只有一个服务器处于激活状态，其他属于睡眠状态，而一旦激活的服务器宕机，那么睡眠的服务器就会被启动&lt;br /&gt;
通过这样的两个技术，就基本实现了资源的最大利用&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数据库存储&lt;/h2&gt;
&lt;p&gt;现在分两种数据库，SQL和NoSQL,其中SQL的代表是MySQL，NoSQL的代表是Mongo&lt;br /&gt;
上面说到了负载均衡和容余，其实在数据库系统中也有类似的机制，其中MySQL拥有一种叫做主从服务器的机制，就是说，主服务器进行数据库增添改，然后会通过一种bin log的日志把数据同步到从属服务器中然后，所有的搜索命令会使用从属服务器去处理&lt;br /&gt;
还有一个重要的问题就是数据库搜索加速，一种做法就是索引，或者使用外部的索引系统，二就是实现分表分区，所谓分表就是把数据分在不同的表内，但是缺点就是需要修改SQL命令，而分区的做法就是逻辑不变，但是数据库系统自动帮你去在多个表内进行搜索&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;如何进行网络加速&lt;/h2&gt;
&lt;p&gt;利用代理缓存，代理服务器中可能拥有某些服务，这些服务器中就拥有了缓存池，能够缓存一些静态文件，当然另一种最基本的代理的加速就是代理服务器去帮助用户向主服务器获取数据&lt;br /&gt;
在上面的情况中，主服务器需要做的就是把一些动态文件静态化，便于代理缓存，具体的实现方法其实就是使用一些模板，或者框架，例如PHP的ThinkPHP&lt;br /&gt;
另一种加速方式就是把某些搜索或者IO变成内存级别的搜索，这里用到了一种meocache的技术，这种技术的优点就是数据都在内存中，缺点就是没有存储到本地，解决方案可以使用redies等NoSQL &lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;最后是监控&lt;/h2&gt;
&lt;p&gt;说实话这里实在是没有什么经验，以后如果做了一些，再来补充吧&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jekyll的使用</title>
      <link>place_your_blog_url_here/2014/12/26/yekyll-document.html</link>
      <pubDate>26 Dec 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2014/12/26/yekyll-document</guid>
      <description>&lt;h1 id=&quot;jekyll&quot;&gt;Jekyll&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;jekyll 安装  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jekyll还有两个重要的命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll build  
# =&amp;gt; 根据当前目录里的内容生成静态网页，网页存放到目录 ./_site
$ jekyll serve
# =&amp;gt; 启动服务端部署_site内的网站到 http://localhost:4000,你可以在浏览器里输入这个URL来预览你的博客网站的效果
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后再说说jeyll的文档结构 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── _config.yml  //jekyll的配置文件，jekyll的很多参数可以在输入命令行时直接输入，也可以写入配置文件，简化繁琐的命令输入过程。
├── _drafts  //这个文件夹里面是用来存放草稿的，里面的文件不需要在文件名中加入固定格式的日期前缀。

|   ├── begin-with-the-crazy-ideas.textile  
|   └── on-simplicity-in-technology.markdown  
├── _includes  //这里面可以放置一些可重用的模块来加速开发，你可以方便的将里面的内容在多个文件里复用。譬如你也可以在多个页面中加入一块固定的模块，这个模块存放在文件_includes/file.ext，只需要在文件中插入liquid标签： % include file.ext %] 。
|   ├── footer.html
|   └── header.html
├── _layouts    //这个目录存放的是一些布局文件，我们的post文章里面可以使用YAML前缀格式来设置我们使用的布局。我们可以使用liquid标签  在我们的web页中插入内容。
|   ├── default.html
|   └── post.html
├── _posts    //这里是用来放置你的文章的，里面的文件需要加入日期前缀，格式为： YEAR-MONTH-DAY-title.MARKUP 。前面的日期格式是固定的，jekyll可以自动提取出文件名中的日期前缀用来标识文件发布的日期，这个日期可以用来排序，分类，显示等。

|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile
|   └── 2009-04-26-barcamp-boston-4-roundup.textile
├── _site    jekyll默认会将jekyll项目中的内容生成静态网页放到这个目录中，这个目录是可以自定义的，可以写到配置文件_config.yml中。默认这个目录会加入.gitignore文件中，里面的内容不会上传到github，github page会自动根据你上传的jekyll项目生成对应的网页，而不会直接展示你自己本地生成的网页。

└── index.html   //默认的主页文件，可以在文件头部加入YAML区域，内容中也可以加入Markdown等格式的内容。这个文件也会被jekyll转换成对应网页，不会直接显示你定义的内容。文件后缀可以是：.html, .markdown, .md, .textile 等。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##发布&lt;/p&gt;

&lt;p&gt;那么在整个需要post的文档前面 我们一般都是添加 YAML front matter 来进行记录或者预处理一些东西，格式如下  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
title: Blogging Like a Hacker
---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里我们可以自定义一些属性，如title，但是还是有一些全局的属性&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;layout&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;设置这个变量可以指定使用某个指定的布局文件。布局文件不需要加文件名后缀。布局文件需要放到_layouts文件夹中。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;permalink&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;发布的post的url默认会是/year/month/day/title.html的格式，用户可以设置这个变量来设置静态URL。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;published&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;post设置这个变量为false，那么这个post在产生网页时不会发布。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;category，categories&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Instead of placing posts inside of folders, you can specify one or more categories that the post belongs to. When the site is generated the post will act as though it had been set with these categories normally. 类别(Categories)可以使用YAML列表的形式或者使用空格分隔的字符串形式。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;tags&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;与分类(categories)类似，可以定义一个或多个标签(tags)，同样的也可以用YAML列表形式或空格分隔的字符串形式&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;说完了post文件的头，那么我们就可以说说我们的博客本身了
首先这类的文件可以分成两种，markdown 和 html， 命名如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2011-12-31-new-years-eve-is-awesome.md
2012-09-12-how-to-write-a-blog.textile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###内容格式&lt;br /&gt;
所有的博客文件必须以YAML front-matter开头。然后剩余部分用户就可以自己选择使用哪种格式了。Jekyll提供了两种流行的内容标记格式：Markdown和Textile。每种格式都有自己的标记内容的方法，你需要熟悉这两种格式并选择你自己需要的格式。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;在文章中包含图片及其他资源&lt;/h3&gt;
&lt;p&gt;有时候用户需要在post中添加图片，下载文件或其他内容。因为语法的不同，Markdown和Textlie的链接的表达方式不同，因此存储图片，二进制文件等的位置也有所不同。&lt;/p&gt;

&lt;p&gt;由于Jekyll的灵活性，有很多不同的解决方案来解决这个问题。通用的解决方案是在根目录创建一个文件夹，例如assets或者downloads，图片，下载文件和其他资源就可以放到这个目录下。这样，post中就可以以根目录为起始路径来链接到这些资源文件。当然，这要依赖与你的网站的（子）域名和路径的配置。下面给出一些利用site.url变量来实现的链接(使用Markdown)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;… which is shown in the screenshot below:
![My helpful screenshot](/assets/screenshot.jpg)
… you can [get the PDF](/assets/mydoc.pdf) directly.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;post还可以使用一些属性 url,title,excerpt&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;代码高亮&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
&amp;lt;div class=&quot;highlight&quot;&amp;gt;&amp;lt;pre&amp;gt;&amp;lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&amp;gt;&amp;lt;span class=&quot;k&quot;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;nf&quot;&amp;gt;show&amp;lt;/span&amp;gt;
  &amp;lt;span class=&quot;vi&quot;&amp;gt;@widget&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;o&quot;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;no&quot;&amp;gt;Widget&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;p&quot;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;n&quot;&amp;gt;params&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;[&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;ss&quot;&amp;gt;:id&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;]&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;p&quot;&amp;gt;)&amp;lt;/span&amp;gt;
  &amp;lt;span class=&quot;n&quot;&amp;gt;respond_to&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;k&quot;&amp;gt;do&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;o&quot;&amp;gt;|&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;nb&quot;&amp;gt;format&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;|&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;nb&quot;&amp;gt;format&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;n&quot;&amp;gt;html&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;c1&quot;&amp;gt;# show.html.erb&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;nb&quot;&amp;gt;format&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;o&quot;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;n&quot;&amp;gt;json&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;p&quot;&amp;gt;{&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;n&quot;&amp;gt;render&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;ss&quot;&amp;gt;json&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;p&quot;&amp;gt;:&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;vi&quot;&amp;gt;@widget&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;p&quot;&amp;gt;}&amp;lt;/span&amp;gt;
  &amp;lt;span class=&quot;k&quot;&amp;gt;end&amp;lt;/span&amp;gt;
&amp;lt;span class=&quot;k&quot;&amp;gt;end&amp;lt;/span&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;/div&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##网站的组织形式&lt;br /&gt;
很多网站默认启动服务会找HTML文件index.html作为网站的首页来展示。Jekyll也一样，除非你自己在web服务器上配置了其他文件，否则Jekyll也会默认将index.html文件作为首页。&lt;/p&gt;

&lt;p&gt;在首页中使用布局layouts
Jekyll项目中的任何HTML文件都可以使用布局(layouts)和包含文件(includes)，包括首页。一些通用的元素，例如头部和尾部，可以抽取出来做到布局中，这样方便开发，网站的风格也能统一。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;额外的页面放置在哪？&lt;/h3&gt;

&lt;p&gt;在哪里放置HTML页面文件取决与你想让你的页面如何工作。有两种主要的创建页面的方式：&lt;br /&gt;
放置HTML文件到网站根目录，每个页面单独命名。
在网站根目录为每个页面创建一个单独命名的文件夹，每个文件夹里放置一个名为index.html的文件&lt;br /&gt;
这两种方式都能很好的工作，也可以混合使用，唯一的不同就是最终访问路径URL的不同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes/
|-- _layouts/
|-- _posts/
|-- _site/
|-- about.html    # =&amp;gt; http://yoursite.com/about.html
|-- index.html    # =&amp;gt; http://yoursite.com/
└── contact.html  # =&amp;gt; http://yoursite.com/contact.html

.
├── _config.yml
├── _includes/
├── _layouts/
├── _posts/
├── _site/
├── about/
|   └── index.html  # =&amp;gt; http://yoursite.com/about/
├── contact/
|   └── index.html  # =&amp;gt; http://yoursite.com/contact/
└── index.html      # =&amp;gt; http://yoursite.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;变量&lt;/h2&gt;
&lt;p&gt;全局变量&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;_config.yml文件中配置的全网站范围的信息和配置项。更详细的内容参考下面。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page专用的信息以及YAML Front Matter。用户在YAML front matter中设置的自定义变量也可以在这里使用。更详细的内容参考下面。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;content&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;在布局文件中，post和page的内容会被封装起来。这个变量在post和page文件中没有定义。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;这个变量在变量paginate变量被设置后才产生作用。详细内容参考Pagination&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Site变量 &lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.time&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;当前时间(当你运行jekyll时)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.pages&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;所有pages的列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.posts&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;所有posts的列表，按时间顺序倒序排列。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.related_posts&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;如果当前处理的页面是post，则这个变量包含了至多十个的相关的posts的列表。 By default, these are low quality but fast to compute. For high quality but slow to compute results, run the jekyll command with the –lsi (latent semantic indexing) option.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.categories.CATEGORY&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;所有指定分类CATEGORY中的posts的列表。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.tags.TAG&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;所有包含标签TAG的posts的列表。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;site.[CONFIGURATION_DATA]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;所有通过命令行以及通过_config.yml设置的变量都可以通过变量site来访问。例如，在配置文件中设置了url:http://mysite.com，那么在posts和pages中可以通过变量site.url来使用设置的变量值。在watch模式下，Jekyll并不会去解析_config.yml文件，只在Jeykll服务启动的时候才会解析，因此如果你改变了配置项的值，你需要重新启动Jekyll来使改变生效。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Page变量&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.content&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;The un-rendered content of the Page.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.title&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page的标题&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.excerpt&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;The un-rendered excerpt of the Page.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.url&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;post的URL，不包含域名，以”/”开头。例如：/2008/12/14/my-post.html&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.date&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;指定的日期。这个变量可以在post的front matter中指定一个新的日期/时间来覆盖已有的日期，格式为：YYYY-MM-DD HH:MM:SS(假定是UTC世界标准时间)，或者：YYYY-MM-DD HH:MM:SS +/-TTTT(使用一个相对UTC的偏移量来指定时区，例如：2008-12-14 10:30:00 +0900）。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.id&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;post的唯一标识ID(对RSS feeds有用)。例如：/2008/12/14/my-post。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.categories&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;post所属的类别的列表。类别(categories)派生于_posts之上的目录结构。例如，一个设置page.categories变量为[‘work, ‘code’]的post将位于/work/code/_posts/2008-12-24-closures.md。这些可以在YAML Front Matter中进行设置。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.tags&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;post所属的tags的列表。可以在YAML Front Matter中进行设置。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page.path&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;原生post或者page文件的路径。用法实例：链接到github上的page或者post的源文件。可以在YAML Front Matter中覆盖这个变量。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Paginator&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;变量&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginagor.per_page&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;每个page页面包含的posts数目。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.posts&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;page页面可用的posts&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.total_posts&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;posts的总数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.total_pages&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;pages的总数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.page&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;当前page页面的编号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.previous_page&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;前一个page页面的编号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.previous_page_path&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;前一个page页面的path路径&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.next_page&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;后一个page页面的编号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;paginator.next_page_path&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;后一个page页面的path路径&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
  </channel>
</rss>