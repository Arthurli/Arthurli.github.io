<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>place_your_blog_title_here</title>
    <link>place_your_blog_url_here</link>
    <atom:link href="place_your_blog_url_here/rss.xml" rel="self" type="application/rss+xml" />
    <description>place_your_blog_description_here</description>
    <language>place_your_blog_language_here</language>
    <pubDate>Thu, 05 Feb 2015 17:57:47 +0800</pubDate>
    <lastBuildDate>Thu, 05 Feb 2015 17:57:47 +0800</lastBuildDate>

    
    <item>
      <title>AJAX</title>
      <link>place_your_blog_url_here/2015/02/05/AJAX.html</link>
      <pubDate>05 Feb 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2015/02/05/AJAX</guid>
      <description>&lt;h1 id=&quot;ajax&quot;&gt;AJAX&lt;/h1&gt;
&lt;p&gt;AJAX = 异步 JavaScript 和 XML。简单地说就是加载完页面之后还可以通过它去获取和修改数据，然后处理返回的JSON和XML，从而更改页面。 &lt;br /&gt;
AJAX生成了一个XMLHttpRequest对象进行网络连接，一个简单的AJAX例子如下 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;script&amp;gt;
function loadXMLDoc()
{
var xmlhttp;
if (window.XMLHttpRequest)
  {// code for IE7+, Firefox, Chrome, Opera, Safari
  xmlhttp=new XMLHttpRequest();
  }
else
  {// code for IE6, IE5
  xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
  }
xmlhttp.onreadystatechange=function()
  {
  if (xmlhttp.readyState==4 &amp;amp;&amp;amp; xmlhttp.status==200)
    {
    document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;
    }
  }
xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true);
xmlhttp.send();
}
&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;myDiv&quot;&amp;gt;&amp;lt;h2&amp;gt;使用 AJAX 修改该文本内容&amp;lt;/h2&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;button type=&quot;button&quot; onclick=&quot;loadXMLDoc()&quot;&amp;gt;修改内容&amp;lt;/button&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;ajax-1&quot;&gt;AJAX方法&lt;/h1&gt;

&lt;table&gt;
	&lt;thead&gt;
		&lt;td&gt;方法&lt;/td&gt;
		&lt;td&gt; 描述 &lt;/td&gt;
	&lt;/thead&gt;
	&lt;tr&gt;
		&lt;td&gt;open(method,url,async)	&lt;/td&gt;
		&lt;td&gt;
			规定请求的类型、URL 以及是否异步处理请求。
			&lt;ul&gt;
				&lt;li&gt;method：请求的类型；GET 或 POST&lt;/li&gt;
				&lt;li&gt;url：文件在服务器上的位置&lt;/li&gt;
				&lt;li&gt;async：true（异步）或 false（同步)&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;send(string)&lt;/td&gt;
		&lt;td&gt;
			将请求发送到服务器。
			&lt;ul&gt;
				&lt;li&gt;string：仅用于 POST 请求&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; setRequestHeader(header,value)&lt;/td&gt;
		&lt;td&gt;
			向请求添加 HTTP 头。
			&lt;ul&gt;
				&lt;li&gt; header: 规定头的名称 &lt;/li&gt;
				&lt;li&gt; value: 规定头的值 &lt;/li&gt;
			&lt;/ul&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;

&lt;h1 id=&quot;ajax-2&quot;&gt;AJAX响应&lt;/h1&gt;
&lt;p&gt;两种响应 responseText 和 responseXML&lt;br /&gt;
解析XML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xmlDoc=xmlhttp.responseXML;
txt=&quot;&quot;;
x=xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);
for (i=0;i&amp;lt;x.length;i++)
  {
  txt=txt + x[i].childNodes[0].nodeValue + &quot;&amp;lt;br&amp;gt;&quot;;
  }
document.getElementById(&quot;myDiv&quot;).innerHTML=txt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;onreadystatechange-&quot;&gt;onreadystatechange 事件&lt;/h1&gt;

&lt;p&gt;onreadystatechange 事件被触发 5 次（0 - 4），对应着 readyState 的每个变化。  &lt;/p&gt;

&lt;table&gt;
	&lt;thead&gt;
		&lt;td&gt;方法&lt;/td&gt;
		&lt;td&gt; 描述 &lt;/td&gt;
	&lt;/thead&gt;
	&lt;tr&gt;
		&lt;td&gt; onreadystatechange	&lt;/td&gt;
		&lt;td&gt;
			存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。
		&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;send(string)&lt;/td&gt;
		&lt;td&gt;
			存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。
			&lt;ul&gt;
				&lt;li&gt;0: 请求未初始化&lt;/li&gt;
				&lt;li&gt;1: 服务器连接已建立&lt;/li&gt;
				&lt;li&gt;2: 请求已接收&lt;/li&gt;
				&lt;li&gt;3: 请求处理中&lt;/li&gt;
				&lt;li&gt;4: 请求已完成，且响应已就绪&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/td&gt;
		
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt; status &lt;/td&gt;
		&lt;td&gt;
			&lt;ul&gt;
				&lt;li&gt; 200: &quot;OK&quot; &lt;/li&gt;
				&lt;li&gt; 404: 未找到页面 &lt;/li&gt;
			&lt;/ul&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;例子
xmlhttp.onreadystatechange=function()
  {
  if (xmlhttp.readyState==4 &amp;amp;&amp;amp; xmlhttp.status==200)
    {
    document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>解析字符串</title>
      <link>place_your_blog_url_here/2015/02/04/string.html</link>
      <pubDate>04 Feb 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2015/02/04/string</guid>
      <description>&lt;h1 id=&quot;nspredicate&quot;&gt;NSPredicate&lt;/h1&gt;
&lt;p&gt;Cocoa 提供了NSPredicate 用于指定过滤条件，谓词是指在计算机中表示计算真假值的函数，
它使用起来有点儿像SQL 的查询条件，主要用于从集合中分拣出符合条件的对象，也可以
用于字符串的正则匹配。&lt;/p&gt;

&lt;p&gt;在iOS中是创造一个NSPredicate，然后使用NSArray,NSSet,NSOrderedSet…等基础类使用 filter 开始的 Method 和参数 NSPredicate 过滤字符串&lt;/p&gt;

&lt;p&gt;//判断是否匹配对象&lt;br /&gt;
-(BOOL)evaluateWithObject:(id)object;    // evaluate a predicate against a single object&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;1 比较和逻辑运算符&lt;/h3&gt;
&lt;p&gt;==和=、&amp;gt;、&amp;gt;=和=&amp;gt;、&amp;lt;、&amp;lt;=和=&amp;lt;、!=和&amp;lt;&amp;gt;&lt;br /&gt;
此外，谓词字符串语法还支持括号表达式和AND、OR、NOT逻辑运算符或者C样式的等效表达式&amp;amp;&amp;amp;、||和!&lt;br /&gt;
示例：&lt;br /&gt;
predicate=[NSPredicate predicateWithFormat:@”(engine.horsepower&amp;gt;50) AND (engine.horsepower&amp;lt;200)”];&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2 数组运算符&lt;/h3&gt;
&lt;p&gt;predicate=[NSPredicate predicateWithFormat:@”engine.horsepower BETWEEN {50,200}”];&lt;br /&gt;
花括号表示数组，BETWEEN将数组中的第一个元素看成是数组的下界，第二个元素看成是数组的上界。&lt;br /&gt;
可以使用%@格式说明符插入你自己的NSArray对象：&lt;br /&gt;
NSArray *betweens=[NSArray arrayWithObjects:&lt;br /&gt;
                    [NSNumber numberWithInt:50],&lt;br /&gt;
                    [NSNumber numberWithInt:200],nil];&lt;br /&gt;
predicate=[NSPredicate predicateWithFormat:@”engine.horsepower BETWEEN %@”,betweens];  &lt;/p&gt;

&lt;p&gt;也可以使用变量：&lt;br /&gt;
predicateTemplate=[NSPredicate predicateWithFormat:@”engine.horsepower BETWEEN $POWERS”];&lt;br /&gt;
varDict=[NSDictionary dictionaryWithObjectsAndKeys:betweens,@”POWERS”,nil];&lt;br /&gt;
predicate=[predicateTemplate predicateWithSubstitutionVariables:varDict];&lt;br /&gt;
数组并不仅仅用来指定某个区间的端点值，你可以使用IN运算符查找数组中是否含有某个特定值，具有SQL编程经验的编程人员应该对以下代码非常熟悉：&lt;br /&gt;
predicate=[NSPredicate predicateWithFormat:@”name IN {‘Herbie’,’Snugs’,’Badger’,’Flap’}”];  &lt;/p&gt;

&lt;p&gt;ANY，SOME：指定下列表达式中的任意元素。比如，ANY children.age &amp;lt; 18。&lt;br /&gt;
ALL：指定下列表达式中的所有元素。比如，ALL children.age &amp;lt; 18。&lt;br /&gt;
NONE：指定下列表达式中没有的元素。比如，NONE children.age &amp;lt; 18。它在逻辑上等于NOT (ANY …)。  &lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3 字符串运算符&lt;/h3&gt;
&lt;p&gt;前面介绍字符串时，我们介绍过关系运算符。此外，还有一些针对字符串的关系运算符：&lt;br /&gt;
BEGINSWITH&lt;br /&gt;
ENDSWITH&lt;br /&gt;
CONTAINS&lt;br /&gt;
MATCHES：左边的表达式根据ICU v3 的regex风格比较，等于右边的表达式。&lt;/p&gt;

&lt;p&gt;例如：&lt;br /&gt;
“name BEGINSWITH ‘Bad’” 匹配 “Badger” ，使用”name ENDSWITH ‘vis’” 匹配 “Elvis”，以及 “name CONTAINS ‘udg’”  
这些匹配是区分大小写的，也区分重音符。为了减少名称匹配规则，可以为这些运算符添加[c]、[d]或[cd]修饰符。其中，c表示“不区分大小写”，d表示“不区分发音符号”，[cd]表示都不区分。例如 “name BEGINSWITH[cd] ‘HERB’”  
###4  LIKE运算符
通配符： ? 匹配单个字符 * 匹配任意个字符&lt;br /&gt;
“name LIKE ‘*er’” 匹配任何包含er的名称，等效于CONTAINS&lt;br /&gt;
“name LIKE ‘???er*’” &lt;br /&gt;
另外，LIKE也接受[cd]修饰符&lt;br /&gt;
如果你热衷于正则表达式，可以使用MATCHES运算符。赋给该运算符一个正则表达式，谓词将会计算出他的值。&lt;/p&gt;

&lt;h3 id=&quot;self&quot;&gt;5  SELF&lt;/h3&gt;
&lt;p&gt;NSArray *names1=[NSArray arrayWithObjects:@”Herbie”,@”Badger”,@”Judge”,@”Elvis”,nil];&lt;br /&gt;
NSArray *names2=[NSArray arrayWithObjects:@”Judge”,@”Paper Car”,@”Badger”,@”Finto”,nil];  &lt;/p&gt;

&lt;p&gt;predicate=[NSPredicate predicateWithFormat:@”SELF IN %@”,names1];&lt;br /&gt;
results=[names2 filteredArrayUsingPredicate:predicate];&lt;br /&gt;
NSLog(@”%@”,results);  &lt;/p&gt;

&lt;p&gt;输出：
{
 Judge,
 Badger
}&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;6&lt;/h3&gt;
&lt;p&gt;数组操作&lt;/p&gt;

&lt;p&gt;array[index]：指定数组中特定索引处的元素。&lt;br /&gt;
array[FIRST]：指定数组中的第一个元素。&lt;br /&gt;
array[LAST]：指定数组中的最后一个元素。&lt;br /&gt;
array[SIZE]：指定数组的大小。&lt;br /&gt;
布尔值谓词  &lt;/p&gt;

&lt;p&gt;TRUEPREDICATE：结果始终为真的谓词。&lt;br /&gt;
FALSEPREDICATE：结果始终为假的谓词。  &lt;/p&gt;

&lt;h1 id=&quot;nsscanner&quot;&gt;NSScanner&lt;/h1&gt;
&lt;p&gt;这是一个扫描器类 我们用它解析字符串  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSScanner *scanner = [NSScanner scannerWithString:string];
//设置被忽略的字符
scanner.charactersToBeSkipped = [NSCharacterSet whitespaceCharacterSet];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们先写一个没有错误检查的版本。扫描器的工作原理是这样的：它接收一个字符串，并将光标设置在字符串的开始处。然后调用扫描方法，像这样：[sanner scanString:@”=” intoString:NULL]。如果扫描成功，该方法会返回 YES，光标会自动后移。scanCharactersFromSet:intoString: 方法的工作原理和之前的相似，只不过它扫描的是字符集，并将扫描的结果放入第二个参数的字符串指针所指向的地址中。我们使用 &amp;amp;&amp;amp; 对不同的扫描方法进行 “与” 操作。这种方式的好处是只有与 &amp;amp;&amp;amp; 操作符左边的扫描成功时，&amp;amp;&amp;amp; 右边的扫描方法才会被调用。&lt;/p&gt;

&lt;p&gt;简单来说就是逐字逐句的去解析字符串 然后把解析出来的内容可以存储到字典或者进行其他任何操作，需要注意的就是我们如何去处理没有解析成功的内容，这是一个值得处理的饿问题  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSMutableDictionary *result = [NSMutableDictionary dictionary];
while (!scanner.isAtEnd) {
    NSString *key = nil;
    NSString *value = nil;
    NSCharacterSet *letters = [NSCharacterSet letterCharacterSet];
    BOOL didScan = [scanner scanCharactersFromSet:letters intoString:&amp;amp;key] &amp;amp;&amp;amp;
                   [scanner scanString:@&quot;=&quot; intoString:NULL] &amp;amp;&amp;amp;
                   [scanner scanString:@&quot;#&quot; intoString:NULL] &amp;amp;&amp;amp;
                   [scanner scanCharactersFromSet:hexadecimalCharacterSet intoString:&amp;amp;value] &amp;amp;&amp;amp;
                   value.length == 6;
    result[key] = value;
    [scanner scanCharactersFromSet:[NSCharacterSet newlineCharacterSet] 
                        intoString:NULL]; // 继续扫描下一行
}
return result;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;错误的处理
if (!didScan) {
        NSString *message = [NSString stringWithFormat:@&quot;Couldn&#39;t parse: %u&quot;, scanner.scanLocation];
        NSDictionary *errorDetail = @{NSLocalizedDescriptionKey: message};
        *error = [NSError errorWithDomain:MyErrorDomain code:FormatError userInfo:errorDetail];
        return nil;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;nsexpression&quot;&gt;NSExpression&lt;/h1&gt;

&lt;p&gt;用于计算的类
有点说不清楚 直接上代码吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSExpression *expression = [NSExpression expressionWithFormat:@&quot;4 + 5 - 2**3&quot;];
id value = [expression expressionValueWithObject:nil context:nil]; // =&amp;gt; 1

NSArray *numbers = @[@1, @2, @3, @4, @4, @5, @9, @11];
NSExpression *expression = [NSExpression expressionForFunction:@&quot;stddev:&quot; arguments:@[[NSExpression expressionForConstantValue:numbers]]];
id value = [expression expressionValueWithObject:nil context:nil]; // =&amp;gt; 3.21859...

NSExpression *expression = [NSExpression expressionWithFormat:@&quot;FUNCTION(4.2, &#39;factorial&#39;)&quot;];
id value = [expression expressionValueWithObject:nil context:nil]; // 32.578...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;nscache&quot;&gt;NSCache&lt;/h1&gt;
&lt;p&gt;NSCache 基本上就是一个会自动移除对象来释放内存的 NSMutableDictionary
#NSCharacter​Set
获取一个字符集，用于过滤&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString *string = @&quot;Lorem    ipsum dolar   sit  amet.&quot;;
string = [string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];

NSArray *components = [string componentsSeparatedByCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
components = [components filteredArrayUsingPredicate:[NSPredicate predicateWithFormat:@&quot;self &amp;lt;&amp;gt; &#39;&#39;&quot;]];

string = [components componentsJoinedByString:@&quot; &quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，删除字符串首尾的空格；然后用 NSString -componentsSeparatedByCharactersInSet: 在空格处将字符串分割成一个 NSArray；再用一个 NSPredicate 去除空串；最后，用 NSArray -componentsJoinedByString: 用单个空格符将数组重新拼成字符串。注意：这种方法仅适用于英语这种用空格分割的语言。
#NSSort​Descriptor
用于排序，设置一个排序键值，然后设置升序降序，之后就完成了排序，很优雅&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSArray *firstNames = @[ @&quot;Alice&quot;, @&quot;Bob&quot;, @&quot;Charlie&quot;, @&quot;Quentin&quot; ];
NSArray *lastNames = @[ @&quot;Smith&quot;, @&quot;Jones&quot;, @&quot;Smith&quot;, @&quot;Alberts&quot; ];
NSArray *ages = @[ @24, @27, @33, @31 ];

NSMutableArray *people = [NSMutableArray array];
[firstNames enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    Person *person = [[Person alloc] init];
    person.firstName = [firstNames objectAtIndex:idx];
    person.lastName = [lastNames objectAtIndex:idx];
    person.age = [ages objectAtIndex:idx];
    [people addObject:person];
}];

NSSortDescriptor *firstNameSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;firstName&quot;
  ascending:YES
  selector:@selector(localizedStandardCompare:)];
NSSortDescriptor *lastNameSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;lastName&quot;
  ascending:YES
  selector:@selector(localizedStandardCompare:)];
NSSortDescriptor *ageSortDescriptor = [NSSortDescriptor sortDescriptorWithKey:@&quot;age&quot;
  ascending:NO];

NSLog(@&quot;By age: %@&quot;, [people sortedArrayUsingDescriptors:@[ageSortDescriptor]]);
// &quot;Charlie Smith&quot;, &quot;Quentin Alberts&quot;, &quot;Bob Jones&quot;, &quot;Alice Smith&quot;


NSLog(@&quot;By first name: %@&quot;, [people sortedArrayUsingDescriptors:@[firstNameSortDescriptor]]);
// &quot;Alice Smith&quot;, &quot;Bob Jones&quot;, &quot;Charlie Smith&quot;, &quot;Quentin Alberts&quot;


NSLog(@&quot;By last name, first name: %@&quot;, [people sortedArrayUsingDescriptors:@[lastNameSortDescriptor, firstNameSortDescriptor]]);
// &quot;Quentin Alberts&quot;, &quot;Bob Jones&quot;, &quot;Alice Smith&quot;, &quot;Charlie Smith&quot;
&lt;/code&gt;&lt;/pre&gt;

</description>
    </item>
    
    <item>
      <title>Objective-C-RegEx-Categories 正则表达式</title>
      <link>place_your_blog_url_here/2015/02/03/regular.html</link>
      <pubDate>03 Feb 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2015/02/03/regular</guid>
      <description>&lt;h1 id=&quot;nsregularexpression&quot;&gt;NSRegularExpression&lt;/h1&gt;
&lt;p&gt;这是一个使用正则表达式解析字符串的类，下面是他的一些options&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct NSRegularExpressionOptions : RawOptionSetType {
    init(_ rawValue: UInt)
    init(rawValue: UInt)
    
    static var CaseInsensitive: NSRegularExpressionOptions { get } 
    /* Match letters in the pattern independent of case. */
    static var AllowCommentsAndWhitespace: NSRegularExpressionOptions { get } 
    /* Ignore whitespace and #-prefixed comments in the pattern. */
    static var IgnoreMetacharacters: NSRegularExpressionOptions { get } 
    /* Treat the entire pattern as a literal string. */
    static var DotMatchesLineSeparators: NSRegularExpressionOptions { get }
     /* Allow . to match any character, including line separators. */
    static var AnchorsMatchLines: NSRegularExpressionOptions { get } 
    /* Allow ^ and $ to match the start and end of lines. */
    static var UseUnixLineSeparators: NSRegularExpressionOptions { get } 
    /* Treat only \n as a line separator (otherwise, all standard line separators are used). */
    static var UseUnicodeWordBoundaries: NSRegularExpressionOptions { get }
     /* Use Unicode TR#29 to specify word boundaries (otherwise, traditional regular expression word boundaries are used). */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是每次扫描的options&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct NSMatchingOptions : RawOptionSetType {
    init(_ rawValue: UInt)
    init(rawValue: UInt)
    
    static var ReportProgress: NSMatchingOptions { get } 
    /* Call the block periodically during long-running match operations. */
    static var ReportCompletion: NSMatchingOptions { get } 
    /* Call the block once after the completion of any matching. */
    static var Anchored: NSMatchingOptions { get }
     /* Limit matches to those at the start of the search range. */
    static var WithTransparentBounds: NSMatchingOptions { get } 
    /* Allow matching to look beyond the bounds of the search range. */
    static var WithoutAnchoringBounds: NSMatchingOptions { get }
     /* Prevent ^ and $ from automatically matching the beginning and end of the search range. */
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;nstextcheckingresult&quot;&gt;NSTextCheckingResult&lt;/h3&gt;
&lt;p&gt;这是一个搜索返回的结果类&lt;/p&gt;

&lt;h1 id=&quot;objective-c-regex-categories&quot;&gt;Objective-C-RegEx-Categories&lt;/h1&gt;
&lt;p&gt;这个库就是NSRegularExpression的拓展类别&lt;br /&gt;
它定义了两个用来设置搜索参数和返回搜索结果，主要是对NSTextCheckingResult的封装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface RxMatch : NSObject
@property (nonatomic, copy)     NSString* value;    /* The substring that matched the expression. */
@property (nonatomic, assign)   NSRange   range;    /* The range of the original string that was matched. */
@property (nonatomic, copy)     NSArray*  groups;   /* Each object is an RxMatchGroup. */
@property (nonatomic, copy)     NSString* original; /* The full original string that was matched against.  */
@end


@interface RxMatchGroup : NSObject
@property (nonatomic, copy)   NSString* value;
@property (nonatomic, assign) NSRange range;
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当让，这个库里面还有一个NSString的类别，几乎是与NSRegularExpression类别一一对应的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//直接匹配字符
- (BOOL) isMatch:(NSString*)matchee
//直接返回匹配位置
- (int) indexOf:(NSString*)matchee
//简单替换
- (NSString*) replace:(NSString*)string with:(NSString*)replacement
//返回第一个匹配字符串
- (NSString*) firstMatch:(NSString*)str
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section&quot;&gt;正则表达式&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://deerchao.net/tutorials/regex/regex.htm&quot;&gt;半小时正则&lt;/a&gt;&lt;/p&gt;

</description>
    </item>
    
    <item>
      <title>OCMockito学习</title>
      <link>place_your_blog_url_here/2015/02/03/Mock.html</link>
      <pubDate>03 Feb 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2015/02/03/Mock</guid>
      <description>&lt;h1 id=&quot;mock&quot;&gt;Mock是什么&lt;/h1&gt;
&lt;p&gt;mock测试就是在测试过程中，对于某些不容易构造或者 不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。&lt;br /&gt;
下面是百度百科对于Mock关键词的一些描述&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mock对象
这个虚拟的对象就是mock对象。mock对象就是真实对象在调试期间的代替品。

mock对象使用范畴
真实对象具有不可确定的行为，产生不可预测的效果，（如：股票行情，天气预报） 真实对象很难被创建的 真实对象的某些行为很难被触发 真实对象实际上还不存在的（和其他开发小组或者和新的硬件打交道）等等.

使用mock对象测试的关键步骤
使用一个接口来描述这个对象 在产品代码中实现这个接口 在测试代码中实现这个接口 在被测试代码中只是通过接口来引用对象，所以它不知道这个引用的对象是真实对象还是mock对象。

MockObject
使用Mock Object进行测试，主要是用来模拟那些在应用中不容易构造（如HttpServletRequest必须在Servlet容器中才能构造出来）或者比较复杂的对象（如JDBC中的ResultSet对象）从而使测试顺利进行的工具。
目前，在Java阵营中主要的Mock测试工具有JMock，MockCreator，Mockrunner，EasyMock，MockMaker等，在微软的.Net阵营中主要是Nmock，.NetMock等。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;mockito&quot;&gt;Mockito&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://mockito.org/&quot;&gt;Mockito&lt;/a&gt;官网&lt;/p&gt;

&lt;p&gt;我们做测试的时候最纠结的就是可能测试数据涉及到了很多类，我们又不能有对他们一一依赖，所以我们采用一种Mock的模型对象来作为测试使用的某些替代品。 
verify是Mockito的一种十分重要的方法，能检验是否Mock对象的某些方法被调用过,但是没有前后顺序的排列&lt;br /&gt;
verify还可以加一些限制条件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// mock creation
NSMutableArray *mockArray = mock([NSMutableArray class]);

// using mock object
[mockArray addObject:@&quot;one&quot;];
[mockArray removeAllObjects];

// verification
[verify(mockArray) addObject:@&quot;one&quot;];
[verify(mockArray) removeAllObjects];

//加上限制条件
[verifyCount(mockObject, times(5)) someMethod:@&quot;was called five times&quot;];
[verifyCount(mockObject, never()) someMethod:@&quot;was never called&quot;];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一种方法，让我们可以设置相关对mock对象引用的返回值
在iOSZ中是下面这样实现的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// mock creation
NSArray *mockArray = mock([NSArray class]);

// stubbing
[given([mockArray objectAtIndex:0]) willReturn:@&quot;first&quot;];
[given([mockArray objectAtIndex:1]) willThrow:[NSException exceptionWithName:@&quot;name&quot;
                                                                      reason:@&quot;reason&quot;
                                                                    userInfo:nil]];

// following prints &quot;first&quot;
NSLog(@&quot;%@&quot;, [mockArray objectAtIndex:0]);

// follows throws exception
NSLog(@&quot;%@&quot;, [mockArray objectAtIndex:1]);

// following prints &quot;(null)&quot; because objectAtIndex:999 was not stubbed
NSLog(@&quot;%@&quot;, [mockArray objectAtIndex:999]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Argument Matcher（参数匹配器）,针对参数对象，也可以进行某些模拟（在iOS中，使用OCHamcrest实现）例如下面的 startsWith(@”This is”)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// mock creation
NSMutableArray *mockArray = mock([NSMutableArray class]);

// using mock object
[mockArray removeObject:@&quot;This is a test&quot;];

// verification
[verify(mockArray) removeObject:startsWith(@&quot;This is&quot;)];
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;ocmockito&quot;&gt;OCMockito&lt;/h1&gt;

&lt;p&gt;安装，我是用的是COCOAPOD安装，安装的时候遇到很大的问题困扰我，就是targrt我刚开始写成了非测试的项目，然后就是各种运行不了，所以大家要万分注意&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Podfile
target :MyTests, :exclusive =&amp;gt; true do
  pod &#39;OCMockito&#39;, &#39;~&amp;gt; 1.0&#39;
end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>MJExtension 解析</title>
      <link>place_your_blog_url_here/2015/01/29/MJExtension.html</link>
      <pubDate>29 Jan 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2015/01/29/MJExtension</guid>
      <description>&lt;h1 id=&quot;mjextension-&quot;&gt;MJExtension 介绍&lt;/h1&gt;
&lt;p&gt;这是一个把字典转换成为对象的库，按照作者的意思，它的效率是其他解决方案的数倍，那么，今天让我们来学习一下他是怎么来实现的&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;类的解析&lt;/h2&gt;

&lt;h3 id=&quot;mjfoundation&quot;&gt;MJFoundation&lt;/h3&gt;
&lt;p&gt;这个类来判断传入类型是否可以被解析，也就是说是否来自 NSFoundation&lt;/p&gt;

&lt;h3 id=&quot;mjtype&quot;&gt;MJType&lt;/h3&gt;
&lt;p&gt;是一种类型封装,每种Type都是唯一的存在，保存在字典中&lt;/p&gt;

&lt;h3 id=&quot;mjivar&quot;&gt;MJIvar&lt;/h3&gt;
&lt;p&gt;是一个属性的封装,利用Ivar进行初始化，然后通过下面的方法存取和调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MJIvar *ivarObject = objc_getAssociatedObject(self, ivar);
    if (ivarObject == nil) {
        ivarObject = [[self alloc] initWithIvar:ivar];
        objc_setAssociatedObject(self, ivar, ivarObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个类的功能就是通过Ivar获取一些信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString *name = @(ivar_getName(ivar));
NSString *code = @(ivar_getTypeEncoding(ivar));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过初试化之后，MJIvar就拥有了自己的属性名，这样就可以给把它作为KEY，再把传进来的字典进行设置或者提取属性  &lt;/p&gt;

&lt;h3 id=&quot;nsobjectmjivar&quot;&gt;NSObject+MJIvar&lt;/h3&gt;
&lt;p&gt;这里面的方法是遍历当前类的属性，或者直接遍历父类的属性，然后通过block回调&lt;/p&gt;

&lt;h3 id=&quot;nsobjectmjcoding&quot;&gt;NSObject+MJCoding&lt;/h3&gt;
&lt;p&gt;这里面实现了遍历的编码和解码，使用NSObject+MJIvar中的方法会把所有属性都回调回来，我们就可以通过MJLvar来直接编码或者解码&lt;/p&gt;

&lt;h3 id=&quot;nsobjectmjkeyvalue&quot;&gt;NSObject+MJKeyValue&lt;/h3&gt;
&lt;p&gt;首先这个类中定义了一些列协议，用作字典与对象的key不相同时候的转化，还有完成转换之后调用的代理&lt;br /&gt;
然后就是一些转化方法，具体的转化方法就是先讲一切转化成字典，然后遍历类中的所有属性，然后再依次从字典中取出值，然后赋值&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这个类库究竟帮我们做了什么呢，其实就是把我们平时需要手动的一个一个取得值，赋的值，通过运行时获取到这个类中的所有属性，然后帮我们依次去赋值&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS开发进阶 读书笔记</title>
      <link>place_your_blog_url_here/2015/01/23/iOS-tq.html</link>
      <pubDate>23 Jan 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2015/01/23/iOS-tq</guid>
      <description>&lt;h1 id=&quot;ios-&quot;&gt;iOS开发进阶 读书笔记&lt;/h1&gt;

&lt;p&gt;失望 失望 失望 没别的了&lt;/p&gt;

&lt;h2 id=&quot;ios&quot;&gt;第二部分iOS开发实践&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;第十章 内存管理&lt;/h3&gt;
&lt;p&gt;关闭ARC &lt;code&gt;-fno-objc-arc&lt;/code&gt;,iOS的引用计数与Linux的硬链接相似&lt;br /&gt;
使用弱引用解决循环引用的问题  &lt;/p&gt;

&lt;h3 id=&quot;gcd&quot;&gt;第十一章 GCD&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;BLOCK定义

(void)(^ loggerBlock)(void);
loggerBlock = ^{
  NSLog(@&quot;123&quot;);
}
loggerBlock();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;block使用外部的属性 需要加上 __block 的标示
###第十二章 UIWindow
常被用作广告页，介绍页，解锁页等等
###第十五章 UIWebView
web模板 两个开源库 MGTemplateEngine GRMustache&lt;br /&gt;
cordova 方案传递参数&lt;br /&gt;
###第十八章 实战
持久化 NSJSONSerialization比NSKeyedArchiver好&lt;/p&gt;

</description>
    </item>
    
    <item>
      <title>各种缓存机制和实现方式</title>
      <link>place_your_blog_url_here/2015/01/14/cache.html</link>
      <pubDate>14 Jan 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2015/01/14/cache</guid>
      <description>&lt;h1 id=&quot;section&quot;&gt;各种缓存机制和实现方式&lt;/h1&gt;
&lt;p&gt;今天我们要看的就是缓存机制，在我们的计算机世界里面，内存和速度是怎么都会觉得不够的，当然这只是我自己的感觉而已。那么今天我们就来看看一般的缓存都是如何做的吧&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;为什么使用缓存呢&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;我感觉第一点就是加快访问速度，不适用内存级别的缓存的话，就只能使用数据库，那么频繁的数据库IO自然会使得速度变慢，从而造成用户的流失。  &lt;/li&gt;
  &lt;li&gt;大量的数据库访问自然会增大出现问题的几率，增大请求次数，从而增加不必要的成本&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;那么我们来聊聊缓存吧&lt;/h2&gt;

&lt;p&gt;缓存说白了就是一堆内存中或者数据库中的数据，需要被用户使用，所以放到一个叫做缓存池的地方，大家通过一个唯一标示ID来表明身份，如果缓存数大于上线，那么会根据缓存算法清除掉一些缓存&lt;br /&gt;
还有关于缓存拥有一大堆高大上的术语，想知道的点&lt;a href=&quot;http://unicorn.blog.51cto.com/2273096/444605&quot;&gt;这里&lt;/a&gt;  &lt;/p&gt;

&lt;h2 id=&quot;lfu&quot;&gt;LFU缓存算法&lt;/h2&gt;
&lt;p&gt;LFU 的英文就是 least frequently used, 核心思想就是按照使用频域来排序， 记录缓存的使用频率，然后使用它排序，之后每进来一个新的 就替换掉使用频率最低的换粗  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/LFU.png&quot; alt=&quot;&quot; /&gt;  &lt;/p&gt;

&lt;p&gt;实现起来是这样的(这是我自己想的一种算法实现，不一定是最优解)，缓存池维护一个字典和一个数组，字典存储Key和一个下标数字或者对象（是用于定位用的），而数组则是用来排序的，每次有新的缓存的话，重新排序，然后把最新的数据删除&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/yunhua_lee/article/details/7648549&quot;&gt;这里是别处的详细说明&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/Arthurli/LFUCacheKit&quot;&gt;这里有我用Swift写的一个小实现&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;几种变体&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LFU* : 只删除引用计数为一的缓存数据，如果没有为一的，那么不存储缓存&lt;/li&gt;
  &lt;li&gt;LFU-Aging : 在引用计数的维度上增加一个增加时间，但是这个时间并不是真正的时间，而是根据一个平均引用计数，当平均引用计数达到一定值的时候，所有引用计数减少，可以直接减半，或者减去一个固定的值，然后从新排序&lt;/li&gt;
  &lt;li&gt;LFU*-Aging : 结合以上两种算法&lt;/li&gt;
  &lt;li&gt;Window-LFU : LRU的改进版，只维护一定时间内的引用计数，我的实现方法就是增加一个栈维护请求，此请求数组达到上限，推出最早的请求，引用计数减一，然后从新排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lru&quot;&gt;LRU&lt;/h2&gt;
&lt;p&gt;LRU的英文是Least Recently Used,简单来说就是把最久不使用的缓存删除，每次有新的缓存都会把他放到栈顶，然后从栈的底部推出最久不使用的缓存&lt;br /&gt;
简单的原理图就像下面画的&lt;br /&gt;
&lt;img src=&quot;/assets/img/LRU.png&quot; alt=&quot;&quot; /&gt;  &lt;br /&gt;
还是不太清楚？那么我们来看这个&lt;br /&gt;
&lt;img src=&quot;/assets/img/LRU-1.png&quot; alt=&quot;&quot; /&gt; &lt;br /&gt;
永远都是把最近访问的缓存放到顶部，然后把底部的缓存删除&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/yunhua_lee/article/details/7599671&quot;&gt;这里是别处的详细说明&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/Arthurli/LRUCacheKit&quot;&gt;这里有我用Swift写的一个小实现&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;几种变体&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LRU2 : 按我的理解就是维护一个LFU队列和一个LRU队列，当LFU队列的访问数达到某个值，则从LFU队列中移动到LRU队列，两个队列如果超出，都是用各自的方式删除缓存&lt;/li&gt;
  &lt;li&gt;2Q : 和LRU2相类似，不过换成了维护一个FIFO队列和LRU队列&lt;/li&gt;
  &lt;li&gt;MRU (Most Recently Used): 最近最常使用缓存算法，与LRU完全相反，首先删除最新的缓存，多应用于文件顺序执行的场景&lt;/li&gt;
  &lt;li&gt;MQ : 维护多个拥有优先级设定的LRU队列，然后根据访问次数，和被访问时间升降优先级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/LRU-MQ.png&quot; alt=&quot;&quot; /&gt;   &lt;/p&gt;

&lt;h2 id=&quot;fifo&quot;&gt;FIFO&lt;/h2&gt;
&lt;p&gt;原始版的FIFO就是先进先出，除了快也就没什么优点了，咱们主要说说几种变化&lt;br /&gt;
###Second Chance 
核心思想就是数据被淘汰前被访问过两次则再给他个机会，什么叫给机会呢，如果访问数大于2，则把重置访问数，然后把这个缓存从队头移动到队尾
###Clock
Clock是Second Chance的改进版，通过一个环形队列，避免将数据在FIFO队列中移动。&lt;br /&gt;
它只需要移动指针就好了，优于Second Chance&lt;/p&gt;

&lt;h2 id=&quot;adaptive-replacement-cachearc&quot;&gt;Adaptive Replacement Cache（ARC）&lt;/h2&gt;
&lt;p&gt;学过oc的都激动了，我懂，我说，你懂个毛线，不一样好吗，说的不是一个东西好吗&lt;br /&gt;
那么什么叫做ARC呢，其实也就是维护了两个LRU队列，然后…然后…&lt;/p&gt;

&lt;p&gt;我就简单说说，说的不好。维护两个LRU队列，每个队列还有一个垃圾箱，我们分别取名T1,L1,T2,L2  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新数据进入L1&lt;/li&gt;
  &lt;li&gt;多次被访问进入L2&lt;/li&gt;
  &lt;li&gt;L1被移除进入T1，L2被移除进入T2&lt;/li&gt;
  &lt;li&gt;T2满了，进入L1，T1满了被真正移出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Adaptive_replacement_cache#Deployment&quot;&gt;这里是详细&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;其实缓存算法还有很多很多，我们现在说的只是最常使用的几个缓存算法，我们需要根据不同的使用场景选择适合我们的算法&lt;/p&gt;

</description>
    </item>
    
    <item>
      <title>SQL细节补全</title>
      <link>place_your_blog_url_here/2015/01/12/sql.html</link>
      <pubDate>12 Jan 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2015/01/12/sql</guid>
      <description>&lt;h1 id=&quot;sql&quot;&gt;SQL细节补全&lt;/h1&gt;
&lt;p&gt;-
The SELECT DISTINCT statement is used to return only distinct (different) values.  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT DISTINCT column_name,column_name
FROM table_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ORDER BY keyword is used to sort the result-set.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT column_name,column_name
FROM table_name
ORDER BY column_name,column_name ASC|DESC;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The INSERT INTO statement is used to insert new records in a table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO table_name (column1,column2,column3,...)
VALUES (value1,value2,value3,...);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The UPDATE statement is used to update records in a table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UPDATE table_name
SET column1=value1,column2=value2,...
WHERE some_column=some_value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The SELECT TOP clause is used to specify the number of records to return.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name
LIMIT number;

SELECT TOP number|percent column_name(s)
FROM table_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQL Wildcard Characters&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Wildcard&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;%&lt;/td&gt;
      &lt;td&gt;A substitute for zero or more characters&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;_&lt;/td&gt;
      &lt;td&gt;A substitute for a single character&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[charlist]&lt;/td&gt;
      &lt;td&gt;Sets and ranges of characters to match&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[^charlist] or [!charlist]&lt;/td&gt;
      &lt;td&gt;Matches only a character NOT specified within the brackets&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;SQL aliases are used to temporarily rename a table or a column heading.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT column_name AS alias_name
FROM table_name;

SELECT column_name(s)
FROM table_name AS alias_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The SQL UNION operator combines the result of two or more SELECT statements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;

//Note: The UNION operator selects only distinct values by default. To allow duplicate values, use the ALL keyword with UNION.

SELECT column_name(s) FROM table1
UNION ALL
SELECT column_name(s) FROM table2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With SQL, you can copy information from one table into another.&lt;/p&gt;

&lt;p&gt;The SELECT INTO statement copies data from one table and inserts it into a new table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SELECT *
INTO newtable [IN externaldb]
FROM table1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With SQL, you can copy information from one table into another.&lt;/p&gt;

&lt;p&gt;The INSERT INTO SELECT statement copies data from one table and inserts it into an existing table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO table2
(column_name(s))
SELECT column_name(s)
FROM table1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create Table&lt;/p&gt;

&lt;p&gt;In SQL, we have the following constraints:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NOT NULL - Indicates that a column cannot store NULL value&lt;/li&gt;
  &lt;li&gt;UNIQUE - Ensures that each row for a column must have a unique value&lt;/li&gt;
  &lt;li&gt;PRIMARY KEY - A combination of a NOT NULL and UNIQUE. Ensures that a column (or combination of two or more columns) have an unique identity which helps to find a particular record in a table more easily and quickly&lt;/li&gt;
  &lt;li&gt;FOREIGN KEY - Ensure the referential integrity of the data in one table to match values in another table&lt;/li&gt;
  &lt;li&gt;CHECK - Ensures that the value in a column meets a specific condition&lt;/li&gt;
  &lt;li&gt;DEFAULT - Specifies a default value when specified none for this column&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE Persons
(
PersonID int,
LastName varchar(255),
FirstName varchar(255),
Address varchar(255),
City varchar(255)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The CREATE INDEX statement is used to create indexes in tables.&lt;/p&gt;

&lt;p&gt;Indexes allow the database application to find data fast; without reading the whole table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE INDEX index_name
ON table_name (column_name)

CREATE UNIQUE INDEX index_name
ON table_name (column_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ALTER TABLE statement is used to add, delete, or modify columns in an existing table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ALTER TABLE table_name
ADD column_name datatype

ALTER TABLE table_name
DROP COLUMN column_name

//SQL Server / MS Access:

ALTER TABLE table_name
ALTER COLUMN column_name datatype

//My SQL / Oracle:

ALTER TABLE table_name
MODIFY COLUMN column_name datatype

//Oracle 10G and later:

ALTER TABLE table_name
MODIFY column_name datatype

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Auto-increment allows a unique number to be generated when a new record is inserted into a table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE Persons
(
ID int NOT NULL AUTO_INCREMENT,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (ID)
)

ALTER TABLE Persons AUTO_INCREMENT=100
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JQuery 学习笔记</title>
      <link>place_your_blog_url_here/2015/01/06/jquery.html</link>
      <pubDate>06 Jan 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2015/01/06/jquery</guid>
      <description>&lt;h1 id=&quot;jquery-&quot;&gt;JQuery 学习笔记&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;选择器&lt;/h2&gt;
&lt;p&gt;使用$()选择JQuery对象，他的选择器与CSS的选择器十分的类似&lt;br /&gt;
当然JQuery拥有一些自定义的选择符号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:eq(1)      //第几个元素
:odd    	//偶数的元素
:even       //基数的元素
:nth-child()    //这个选择符相对于元素的父元素而非当前选择的所有元素来计算位置，它可以接受数值、odd或even作为参数
:contains()     //这个区分大小
之后还有一系列基于表单的选择符

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在选择后，其实选择的是一个数组，那么其实可以通过下面的方法获取&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myTag = $(&#39;#myTag&#39;)[0].tagName
var myTags = $(&#39;#myTag&#39;).get(0).tagName
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;事件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$(document).ready()    //页面加载后调用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绑定事件使用bind()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function() {
  $(&#39;#switcher-large&#39;).bind(&#39;click&#39;, function() {
    $(&#39;body&#39;).addClass(&#39;large&#39;);
  });
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用$(this)在function中 代表这个对象&lt;br /&gt;
下面是一些事件&lt;br /&gt;
&lt;img src=&quot;/assets/img/jquery1.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
下面再说一些事件流程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 事件目标
// 未完成的代码
$(document).ready(function() {
  $(&#39;#switcher&#39;).click(function(event) {
    if (event.target == this) {
      $(&#39;#switcher button&#39;).toggleClass(&#39;hidden&#39;);
    }
  });
}); 

// 停止事件传播
$(document).ready(function() {
  $(&#39;#switcher&#39;).click(function(event) {
    $(&#39;#switcher button&#39;).toggleClass(&#39;hidden&#39;);
  });
});

$(document).ready(function() {
  $(&#39;#switcher-default&#39;).addClass(&#39;selected&#39;);

  $(&#39;#switcher button&#39;).click(function(event) {
    var bodyClass = this.id.split(&#39;-&#39;)[1];

    $(&#39;body&#39;).removeClass().addClass(bodyClass);

    $(&#39;#switcher button&#39;).removeClass(&#39;selected&#39;);
    $(this).addClass(&#39;selected&#39;);
    event.stopPropagation();
  });
}); 

// 判断this属性
$(document).ready(function() {
  $(&#39;#switcher&#39;).click(function(event) {
    if ($(event.target).is(&#39;button&#39;)) {  //使用 is 判断
      var bodyClass = event.target.id.split(&#39;-&#39;)[1];

      $(&#39;body&#39;).removeClass().addClass(bodyClass);

      $(&#39;#switcher button&#39;).removeClass(&#39;selected&#39;);
      $(event.target).addClass(&#39;selected&#39;);
      event.stopPropagation();
    }
  });
}); 

// 事件委托 ，有很多种方法 比如live,die等等
$(&#39;#switcher button&#39;).live(&#39;click&#39;, function() {
  var bodyClass = event.target.id.split(&#39;-&#39;)[1];

  $(&#39;body&#39;).removeClass().addClass(bodyClass);

  $(&#39;#switcher button&#39;).removeClass(&#39;selected&#39;);
  $(this).addClass(&#39;selected&#39;);
}); 

// 模仿用户
$(document).ready(function() {
  $(&#39;#switcher&#39;).trigger(&#39;click&#39;);
}); 

//从键盘输入
$(document).ready(function() {
  var triggers = {
    D: &#39;default&#39;,
    N: &#39;narrow&#39;,
    L: &#39;large&#39;
  };

  $(document).keyup(function(event) {
    var key = String.fromCharCode(event.keyCode);
    if (key in triggers) {
      $(&#39;#switcher-&#39; + triggers[key]).click();
    }
  });
}); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;样式与动画&lt;/h2&gt;
&lt;p&gt;首先 .css() 这个方法 继承了getter和setter&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 单个属性及其值
.css(&#39;property&#39;, &#39;value&#39;)
// 属性-值对构成
.css({
  property1: &#39;value1&#39;,
  &#39;property-2&#39;: &#39;value2&#39;
}) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用hide和show现实和隐藏元素，其中还可以使用’slow’、’normal’和’fast’来当做速度的参数&lt;br /&gt;
我们使用fadeIn和fadeOut实现淡出和淡入 &lt;br /&gt;
使用和slideDown和slideUp实现划上和滑下&lt;br /&gt;
jquery还可以使用。animate()自定义动画，这里面有可以设置该标的元素，速度，回调等，是一个并发的方法，&lt;br /&gt;
如果我们需要一个队列效果执行的动画呢，可以连缀多个animate()动画&lt;br /&gt;
如果在速度选项中添加 queue:false，则不是使用队列触发&lt;/p&gt;

&lt;h2 id=&quot;dom&quot;&gt;DOM操作&lt;/h2&gt;
&lt;p&gt;我们可以使用addClass()和removeClass()来添加Class，对于其他的一些属性，我们则可以通过attr()和removeAttr()来添加和删除。&lt;br /&gt;
使用attr赋值的时候其实可以不传值，传递一个function这样每次都会调用这个方法&lt;br /&gt;
在jQuery可以使用.prop获取属性   &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 取得 &quot;checked&quot; 属性的当前值
var currentlyChecked = $(&#39;.my-checkbox&#39;).prop(&#39;checked&#39;);

// 设置 &quot;checked&quot; 属性的值
$(&#39;.my-checkbox&#39;).prop(&#39;checked&#39;, false); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###添加，移动元素
(1) .insertBefore()在现有元素外部、之前添加内容；&lt;br /&gt;
(2) .prependTo()在现有元素内部、之前添加内容；&lt;br /&gt;
(3) .appendTo()在现有元素内部、之后添加内容；&lt;br /&gt;
(4) .insertAfter()在现有元素外部、之后添加内容。&lt;br /&gt;
与之对应的还有反向插入方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function() {
  $(&#39;&amp;lt;a href=&quot;#top&quot;&amp;gt;back to top&amp;lt;/a&amp;gt;&#39;).insertAfter(&#39;div.chapterp&#39;);
  $(&#39;&amp;lt;a id=&quot;top&quot;&amp;gt;&amp;lt;/a&amp;gt;&#39;).prependTo(&#39;body&#39;);
}); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;移动元素和插入元素相似，只不过是选择已经存在的元素  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//包装元素
$(document).ready(function() {
  $(&#39;span.footnote&#39;)
    .insertBefore(&#39;#footer&#39;)
    .wrapAll(&#39;&amp;lt;ol id=&quot;notes&quot;&amp;gt;&amp;lt;/ol&amp;gt;&#39;) //我们使用.wrapAll()把所有脚注都包含在一个&amp;lt;ol&amp;gt;中
    .wrap(&#39;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&#39;); //使用.wrap()将每一个脚注分别包装在自己的&amp;lt;li&amp;gt;中
});

//复制
$(&#39;123&#39;).clone()
$(&#39;123&#39;).clone(true) //同时复制事件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###简单总结
对于jQuery提供的大量DOM操作方法，应该根据要完成的任务和元素的位置作出不同的选择。本章只介绍了一部分DOM操作方法，但其他方法的使用与这些方法类似；第12章还将更全面地讨论DOM操作方法。下面，我们简单地归纳出一些方法，这些方法几乎能够在任何情况下，完成任何任务。&lt;br /&gt;
(1) 要在HTML中创建新元素，使用$()函数。&lt;br /&gt;
(2) 要在每个匹配的元素中插入新元素，使用：&lt;br /&gt;
append()&lt;br /&gt;
appendTo()&lt;br /&gt;
prepend()
prependTo()&lt;br /&gt;
(3) 要在每个匹配的元素相邻的位置上插入新元素，使用：&lt;br /&gt;
after()&lt;br /&gt;
insertAfter()&lt;br /&gt;
before()&lt;br /&gt;
insertBefore()&lt;br /&gt;
(4) 要在每个匹配的元素外部插入新元素，使用： 
wrap()&lt;br /&gt;
wrapAll()&lt;br /&gt;
wrapInner()&lt;br /&gt;
(5) 要用新元素或文本替换每个匹配的元素，使用：&lt;br /&gt;
html()&lt;br /&gt;
text()&lt;br /&gt;
replaceAll()&lt;br /&gt;
replaceWith()&lt;br /&gt;
(6) 要移除每个匹配的元素中的元素，使用：&lt;br /&gt;
empty()&lt;br /&gt;
(7) 要从文档中移除每个匹配的元素及其后代元素，但不实际删除它们，使用：&lt;br /&gt;
remove()&lt;br /&gt;
detach()  &lt;/p&gt;

&lt;h2 id=&quot;ajax&quot;&gt;AJAX的使用&lt;/h2&gt;
&lt;p&gt;在下面的事件中返回false,防止跳转&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//简单加载html
$(document).ready(function() {
  $(&#39;#letter-a a&#39;).click(function() {
    $(&#39;#dictionary&#39;).load(&#39;a.html&#39;);
    return false;
  });
}); 

//加载JSON
$(document).ready(function() {
  $(&#39;#letter-b a&#39;).click(function() {
    $.getJSON(&#39;b.json&#39;, function(data) {
      var html = &#39;&#39;;
      $.each(data, function(entryIndex, entry) {
        html += &#39;&amp;lt;div class=&quot;entry&quot;&amp;gt;&#39;;
        html += &#39;&amp;lt;h3 class=&quot;term&quot;&amp;gt;&#39; + entry.term + &#39;&amp;lt;/h3&amp;gt;&#39;;
        html += &#39;&amp;lt;div class=&quot;part&quot;&amp;gt;&#39; + entry.part + &#39;&amp;lt;/div&amp;gt;&#39;;
        html += &#39;&amp;lt;div class=&quot;definition&quot;&amp;gt;&#39;;
        html += entry.definition;
        html += &#39;&amp;lt;/div&amp;gt;&#39;;
        html += &#39;&amp;lt;/div&amp;gt;&#39;;
      });
      $(&#39;#dictionary&#39;).html(html);
    });
    return false;
  });
}); 

//加载JS
$(document).ready(function() {
  $(&#39;#letter-c a&#39;).click(function() {
    $.getScript(&#39;c.js&#39;);
    return false;
  });
}); 

//加载XML
$(document).ready(function() {
  $(&#39;#letter-d a&#39;).click(function() {
    $.get(&#39;d.xml&#39;, function(data) {
      $(&#39;#dictionary&#39;).empty();
      $(data).find(&#39;entry&#39;).each(function() {
        var $entry = $(this);
        var html = &#39;&amp;lt;div class=&quot;entry&quot;&amp;gt;&#39;;
        html += &#39;&amp;lt;h3 class=&quot;term&quot;&amp;gt;&#39; + $entry.attr(&#39;term&#39;);
          html += &#39;&amp;lt;/h3&amp;gt;&#39;;
        html += &#39;&amp;lt;div class=&quot;part&quot;&amp;gt;&#39; + $entry.attr(&#39;part&#39;);
          html += &#39;&amp;lt;/div&amp;gt;&#39;;
        html += &#39;&amp;lt;div class=&quot;definition&quot;&amp;gt;&#39;;
        html += $entry.find(&#39;definition&#39;).text();
        var $quote = $entry.find(&#39;quote&#39;);
        if ($quote.length) {
          html += &#39;&amp;lt;div class=&quot;quote&quot;&amp;gt;&#39;;
          $quote.find(&#39;line&#39;).each(function() {
            html += &#39;&amp;lt;div class=&quot;quote-line&quot;&amp;gt;&#39;;
              html += $(this).text() + &#39;&amp;lt;/div&amp;gt;&#39;;
          });
          if ($quote.attr(&#39;author&#39;)) {
            html += &#39;&amp;lt;div class=&quot;quote-author&quot;&amp;gt;&#39;;
              html += $quote.attr(&#39;author&#39;) + &#39;&amp;lt;/div&amp;gt;&#39;;
          }
          html += &#39;&amp;lt;/div&amp;gt;&#39;;
        }
        html += &#39;&amp;lt;/div&amp;gt;&#39;;
        html += &#39;&amp;lt;/div&amp;gt;&#39;;
        $(&#39;#dictionary&#39;).append($(html));
      });
    });
    return false;
  });
}); 

//使用get请求PHP
$(document).ready(function() {
  $(&#39;#letter-e a&#39;).click(function() {
    var requestData = {term: $(this).text()};
    $.get(&#39;e.php&#39;, requestData, function(data) {
      $(&#39;#dictionary&#39;).html(data);
    });
    return false;
  });
});

//使用POST请求
$(document).ready(function() {
  $(&#39;#letter-e a&#39;).click(function() {
    var requestData = {term: $(this).text()};
    $.post(&#39;e.php&#39;, requestData, function(data) {
      $(&#39;#dictionary&#39;).html(data);
    });
    return false;
  });
}); 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>CSS选择器</title>
      <link>place_your_blog_url_here/2015/01/05/css-selected.html</link>
      <pubDate>05 Jan 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/2015/01/05/css-selected</guid>
      <description>&lt;h1 id=&quot;css&quot;&gt;CSS选择器&lt;/h1&gt;
&lt;p&gt;##先简单介绍几种追简单的选择器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//元素选择器
html {
	color:black;
	}
	
//选择器分组
h1 ,h2 {
  font: 28px Verdana;
  color: blue;
  background: red;
  }

//派生选择器，也可以叫做上下文选择器，下面说的是列表中的strong
li strong {
    font-style: italic;
    font-weight: normal;
  }
  
//id选择器，各种选择器可以组合使用
#red {
	color:red;
	}
#sidebar p {
	font-style: italic;
	text-align: right;
	margin-top: 0.5em;
	}

//类选择器
.center {
	text-align: center
	}
td.fancy {
	color: #f60;
	background: #666;
	}
  
//通配符选择器
* {
  color:red;
  }

//属性选择器
[lang|=en] 
{ 
  color:red; 
}
input[type=&quot;text&quot;]
{
  width:150px;
  display:block;
  margin-bottom:10px;
  background-color:yellow;
  font-family: Verdana, Arial;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性选择器的语法如下&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;选择器&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute]&lt;/td&gt;
      &lt;td&gt;用于选取带有指定属性的元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute=value]&lt;/td&gt;
      &lt;td&gt;用于选取带有指定属性和值的元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute~=value]&lt;/td&gt;
      &lt;td&gt;用于选取属性值中包含指定词汇的元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute|=value]&lt;/td&gt;
      &lt;td&gt;用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute^=value]&lt;/td&gt;
      &lt;td&gt;匹配属性值以指定值开头的每个元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute$=value]&lt;/td&gt;
      &lt;td&gt;匹配属性值以指定值结尾的每个元素。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[attribute*=value]&lt;/td&gt;
      &lt;td&gt;匹配属性值中包含指定值的每个元素。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section&quot;&gt;高级语法&lt;/h2&gt;
&lt;p&gt;属性选择器可以同时选择多个属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a[href][title]
{
color:red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有一点需要注意的是，派生选择器无法确定几层的子类，也就是说所有包括的子类都将要被选择，所以这里还可以使用子类选择器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;h1 &amp;gt; strong {
	color:red;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选了子类，那么我们想选择他的邻居怎么办，对使用相邻兄弟选择器（Adjacent sibling selector），可选择紧接在另一元素后的元素，且二者有相同父元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;h1 + p {
	margin-top:50px;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后要说就是伪类的概念，CSS 伪类用于向某些选择器添加特殊的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;伪类的语法：
selector : pseudo-class {property: value}
CSS 类也可与伪类搭配使用。
selector.class : pseudo-class {property: value}
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;CSS&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;:active&lt;/td&gt;
      &lt;td&gt;向被激活的元素添加样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:focus&lt;/td&gt;
      &lt;td&gt;向拥有键盘输入焦点的元素添加样式。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:hover&lt;/td&gt;
      &lt;td&gt;当鼠标悬浮在元素上方时，向元素添加样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:link&lt;/td&gt;
      &lt;td&gt;向未被访问的链接添加样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:visited&lt;/td&gt;
      &lt;td&gt;向已被访问的链接添加样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:first-child&lt;/td&gt;
      &lt;td&gt;向元素的第一个子元素添加样式。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:lang&lt;/td&gt;
      &lt;td&gt;向带有指定 lang 属性的元素添加样式。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;与伪类相似的还有伪元素，CSS 伪元素用于向某些选择器设置特殊效果。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;CSS&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;:first-letter&lt;/td&gt;
      &lt;td&gt;向文本的第一个字母添加特殊样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:first-line&lt;/td&gt;
      &lt;td&gt;向文本的首行添加特殊样式。&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:before&lt;/td&gt;
      &lt;td&gt;在元素之前添加内容。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:after&lt;/td&gt;
      &lt;td&gt;在元素之后添加内容。&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
    </item>
    
  </channel>
</rss>